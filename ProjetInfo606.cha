<?xml version="1.0"?><st-source><component-created><name>info606</name> <type>package</type></component-created><component-property><name>info606</name> <type>package</type><property>comment</property> <value>'This object has not been commented.'</value></component-property><component-property><name>info606</name> <type>package</type><property>comment</property> <value>'Package pour le projet info606'</value></component-property><class><name>User</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>info606</package></attributes></class><methods><class-id>User</class-id> <category>accessing</category><body package="info606" selector="name">name	^name</body></methods><methods><class-id>User</class-id> <category>accessing</category><body package="info606" selector="name:">name: anObject	name := anObject</body></methods><methods><class-id>User</class-id> <category>initialize-release</category><body package="info606" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	name := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>User class</class-id> <category>instance creation</category><body package="info606" selector="new">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><do-it>Smalltalk</do-it><comment><class-id>User</class-id><body>Instance Variables:	name	&lt;MessageForwarder | Object | ProtoObject | ProtoObject&gt;	description of name</body></comment><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>User</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>User</staticKey> <definitionChange>added</definitionChange></component_static_change><do-it>User removeFromSystem</do-it><class><name>Class</name><environment>Core</environment><super>Core.ClassDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name classPool environment user </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><methods><class-id>Core.Class</class-id> <category>accessing</category><body package="Kernel-Classes" selector="user">user	^user</body></methods><methods><class-id>Core.Class</class-id> <category>accessing</category><body package="Kernel-Classes" selector="user:">user: anObject	user := anObject</body></methods><comment><class-id>Core.Class</class-id><body>Instances of class Class describe the representation and behavior of objects.  Class adds more comprehensive programming support facilities to the basic attributes of Behavior and the descriptive facilities of ClassDescription.  An example is accessing shared (pool) variables.Instance Variables:	name		&lt;Symbol&gt; name of class for printing and global reference	classPool	&lt;PoolDictionary | nil&gt; of variables common to all instances	environment	&lt;Namespace | nil&gt; the name space corresponding to this class	user		&lt;User&gt; name of user created the class</body></comment><class><name>UserArray</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>info606</package></attributes></class><methods><class-id>UserArray</class-id> <category>initialize-release</category><body package="info606" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>UserArray class</class-id> <category>instance creation</category><body package="info606" selector="new">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>UserArray</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>UserArray</staticKey> <definitionChange>added</definitionChange></component_static_change><do-it>UserArray removeFromSystem</do-it><class><name>UserArray</name><environment>Smalltalk</environment><super>Core.Array</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>info606</package></attributes></class><methods><class-id>UserArray</class-id> <category>initialize-release</category><body package="info606" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><comment><class-id>UserArray</class-id><body>UserArray has not been commented.  The comment should state the purpose of the class and also explain any unobvious aspects of the implementation.</body></comment><component-created><name>model</name> <type>package</type></component-created><component-created><name>info606</name> <type>bundle</type></component-created><bundle-structure><name>info606</name> <structure>#()</structure></bundle-structure><component-property><name>info606</name> <type>bundle</type><property>comment</property> <value>'This object has not been commented.'</value></component-property><component-created><name>model</name> <type>package</type></component-created><bundle-structure><name>info606</name> <structure>#(#(#package 'model'))</structure></bundle-structure><bundle-structure><name>info606</name> <structure>#(#(#package 'model'))</structure></bundle-structure><component-property><name>model</name> <type>package</type><property>comment</property> <value>'This object has not been commented.'</value></component-property><class><name>UserArray</name><environment>Smalltalk</environment><super>Core.Array</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>model</package></attributes></class><methods><class-id>UserArray</class-id> <category>initialize-release</category><body package="model" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><comment><class-id>UserArray</class-id><body>UserArray has not been commented.  The comment should state the purpose of the class and also explain any unobvious aspects of the implementation.</body></comment><component-created><name>controller</name> <type>package</type></component-created><component-created><name>controller</name> <type>package</type></component-created><bundle-structure><name>info606</name> <structure>#(#(#package 'model') #(#package 'controller'))</structure></bundle-structure><bundle-structure><name>info606</name> <structure>#(#(#package 'model') #(#package 'controller'))</structure></bundle-structure><component-property><name>controller</name> <type>package</type><property>comment</property> <value>'This object has not been commented.'</value></component-property><component-created><name>view</name> <type>package</type></component-created><bundle-structure><name>info606</name> <structure>#(#(#package 'model') #(#package 'controller') #(#package 'view'))</structure></bundle-structure><bundle-structure><name>info606</name> <structure>#(#(#package 'model') #(#package 'controller') #(#package 'view'))</structure></bundle-structure><component-property><name>view</name> <type>package</type><property>comment</property> <value>'This object has not been commented.'</value></component-property><methods><class-id>UserArray class</class-id> <category>instance creation</category><body package="model" selector="searchAndCreate">searchAndCreate	"Search an instance of UserArray and create it if not exist"	</body></methods><methods><class-id>UserArray class</class-id> <category>accessing</category><body package="model" selector="classInstance">classInstance	^classInstance</body></methods><methods><class-id>UserArray class</class-id> <category>accessing</category><body package="model" selector="classInstance:">classInstance: anObject	classInstance := anObject</body></methods><methods><class-id>UserArray class</class-id> <category>instance creation</category><body package="model" selector="searchAndCreate">searchAndCreate	"Search an instance of UserArray and create it if not exist"		UserArray classInstance</body></methods><methods><class-id>UserArray class</class-id> <category>instance creation</category><body package="model" selector="searchAndCreate">searchAndCreate	"Search an instance of UserArray and create it if not exist"		((UserArray classInstance) = nil) ifTrue: [		UserArray classInstance: (UserArray new).		].		^(UserArray classInstance)</body></methods><comment><class-id>UserArray</class-id><body>UserArray has not been commented.  The comment should state the purpose of the class and also explain any unobvious aspects of the implementation.</body></comment><comment><class-id>UserArray</class-id><body>UserArray has not been commented.  The comment should state the purpose of the class and also explain any unobvious aspects of the implementation.classInstance -&gt; Variable pour la classe</body></comment><comment><class-id>UserArray</class-id><body>UserArray has not been commented.  The comment should state the purpose of the class and also explain any unobvious aspects of the implementation.</body></comment><class><name>ChoiceUserInterface</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>view</package></attributes></class><methods><class-id>ChoiceUserInterface class</class-id> <category>interface specs</category><body package="view" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Choice user' 			#bounds: #(#{Graphics.Rectangle} 10 32 300 91 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 12 0 17 0 148 0 38 0 ) 					#name: #MenuButton1 					#label: 					#(#{Kernel.UserMessage} 						#key: nil 						#defaultString: 'UserChoice' 						#catalogID: #'UserArray searchAndCreate' ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 181 0 17 0 264 0 38 0 ) 					#name: #ActionButton1 					#label: 'Manage users' 					#isDefault: false 					#defaultable: true ) ) ) )</body></methods><comment><class-id>ChoiceUserInterface</class-id><body>ChoiceUserInterface has not been commented.  The comment should state the purpose of the class and also explain any unobvious aspects of the implementation.</body></comment><class><name>ManageUserInterface</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>view</package></attributes></class><methods><class-id>ManageUserInterface class</class-id> <category>interface specs</category><body package="view" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Manage users' 			#bounds: #(#{Graphics.Rectangle} 879 539 1168 771 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 18 0 16 0 154 0 180 0 ) 					#name: #List1 					#model: #'UserArray searchAndCreate' 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 23 0 199 0 75 0 220 0 ) 					#name: #ActionButton1 					#label: 'Remove' 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 178 0 16 0 278 0 41 0 ) 					#name: #InputField1 					#type: #string ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 222 0 53 0 274 0 74 0 ) 					#name: #ActionButton2 					#label: 'Add' 					#defaultable: true ) ) ) )</body></methods><comment><class-id>ManageUserInterface</class-id><body>ManageUserInterface has not been commented.  The comment should state the purpose of the class and also explain any unobvious aspects of the implementation.</body></comment><class><name>ManageUserController</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>controller</package></attributes></class><methods><class-id>ManageUserController</class-id> <category>initialize-release</category><body package="controller" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>ManageUserController class</class-id> <category>instance creation</category><body package="controller" selector="new">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><comment><class-id>ManageUserController</class-id><body>ManageUserController has not been commented.  The comment should state the purpose of the class and also explain any unobvious aspects of the implementation.</body></comment><do-it>ScheduledWindow new    label: 'Hello';    open</do-it><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>ManageUserController</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>ManageUserController</staticKey> <definitionChange>added</definitionChange></component_static_change><do-it>ManageUserController removeFromSystem</do-it><methods><class-id>ManageUserInterface class</class-id> <category>interface specs</category><body package="view" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Manage users' 			#bounds: #(#{Graphics.Rectangle} 816 448 1105 680 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 18 0 16 0 154 0 180 0 ) 					#name: #userList 					#model: #userList 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 23 0 199 0 75 0 220 0 ) 					#name: #removeUser 					#model: #removeUser 					#label: 'Remove' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 222 0 53 0 274 0 74 0 ) 					#name: #addUser 					#model: #addUser 					#label: 'Add' 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 177 0 17 0 277 0 42 0 ) 					#name: #userName 					#model: #userName ) ) ) )</body></methods><class><name>ManageUserInterface</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>userName userList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>view</package></attributes></class><do-it>Smalltalk defineClass: #ManageUserInterface	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: ' userName userList '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>ManageUserInterface</class-id> <category>actions</category><body package="view" selector="addUser">addUser	"This stub method was generated by UIDefiner"	^self</body></methods><methods><class-id>ManageUserInterface</class-id> <category>actions</category><body package="view" selector="removeUser">removeUser	"This stub method was generated by UIDefiner"	^self</body></methods><methods><class-id>ManageUserInterface</class-id> <category>aspects</category><body package="view" selector="userName">userName	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^userName isNil		ifTrue:			[userName := String new asValue]		ifFalse:			[userName]</body></methods><methods><class-id>ManageUserInterface</class-id> <category>aspects</category><body package="view" selector="userList">userList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^userList isNil		ifTrue:			[userList := SelectionInList new]		ifFalse:			[userList]</body></methods><methods><class-id>ManageUserInterface</class-id> <category>actions</category><body package="view" selector="addUser">addUser	self userName value.	^self</body></methods><methods><class-id>ManageUserInterface</class-id> <category>actions</category><body package="view" selector="addUser">addUser	self userName value.</body></methods><class><name>ManageUserController</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>controller</package></attributes></class><methods><class-id>ManageUserController</class-id> <category>initialize-release</category><body package="controller" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>ManageUserController class</class-id> <category>instance creation</category><body package="controller" selector="new">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><comment><class-id>ManageUserController</class-id><body>ManageUserController has not been commented.  The comment should state the purpose of the class and also explain any unobvious aspects of the implementation.</body></comment><do-it>Array</do-it><methods><class-id>ManageUserController</class-id> <category>initialize-release</category><body package="controller" selector="addUser:">addUser: userName	UserArray searchAndCreate add: userName</body></methods><do-it>ManageUserController organization addCategory: #controlling</do-it><do-it>ManageUserController organization addCategory: #controlling</do-it><do-it>ManageUserController classifySymbol: #addUser: under: #controlling</do-it><methods><class-id>ManageUserInterface</class-id> <category>actions</category><body package="view" selector="addUser">addUser	| c |	c := ManageUserController new.	c addUser: self userName value.</body></methods><methods><class-id>ManageUserInterface</class-id> <category>actions</category><body package="view" selector="addUser">addUser	self userName value: 'Hello'.</body></methods><methods><class-id>ManageUserInterface</class-id> <category>actions</category><body package="view" selector="addUser">addUser	| c |	c := ManageUserController new.	c addUser: self userName value.</body></methods><methods><class-id>ManageUserInterface</class-id> <category>actions</category><body package="view" selector="addUser">addUser	self userName value: 'Hello'</body></methods><methods><class-id>ManageUserInterface</class-id> <category>actions</category><body package="view" selector="addUser">addUser	| c |	c := ManageUserController new.	self userName value: 'Hello'</body></methods><methods><class-id>ManageUserInterface</class-id> <category>actions</category><body package="view" selector="addUser">addUser	| c |	c = ManageUserController new.	self userName value: 'Hello'</body></methods><methods><class-id>ManageUserInterface</class-id> <category>actions</category><body package="view" selector="addUser">addUser	| c |	c = ManageUserController new.	c addUser: self userName value: 'Hello'</body></methods><methods><class-id>ManageUserInterface</class-id> <category>actions</category><body package="view" selector="addUser">addUser	| c |	c := ManageUserController new.	c addUser: self userName value: 'Hello'</body></methods><methods><class-id>ManageUserInterface</class-id> <category>actions</category><body package="view" selector="addUser">addUser	| c |	c := ManageUserController new.	c addUser: self userName value.</body></methods><methods><class-id>ManageUserController</class-id> <category>controlling</category><body package="controller" selector="addUser:">addUser: userName	"Add the user to the UserArray"</body></methods><methods><class-id>UserArray class</class-id> <category>instance creation</category><body package="model" selector="getInstance">getInstance	"Search an instance of UserArray and create it if not exist"		((UserArray classInstance) = nil) ifTrue: [		UserArray classInstance: (UserArray new).		].		^(UserArray classInstance)</body></methods><remove-selector><class-id>UserArray class</class-id> <selector>searchAndCreate</selector></remove-selector><methods><class-id>ManageUserController</class-id> <category>controlling</category><body package="controller" selector="addUser:">addUser: userName	"Add the user to the UserArray"		UserArray getInstance add: userName.</body></methods><do-it>UserArray organization addCategory: #adding</do-it><methods><class-id>UserArray</class-id> <category>adding</category><body package="model" selector="add:">add: anObject	self at: (self size +1) put: anObject.</body></methods><methods><class-id>UserArray</class-id> <category>adding</category><body package="model" selector="add:">add: anObject		self at: (self size +1) put: anObject.</body></methods><do-it>c := UserArray new.</do-it><remove-selector><class-id>UserArray</class-id> <selector>add:</selector></remove-selector><do-it>UserArray organization removeCategory: #adding</do-it><do-it>c</do-it><do-it>UserArray organization addCategory: #adding</do-it><methods><class-id>UserArray</class-id> <category>adding</category><body package="model" selector="add:">add: anObject</body></methods><methods><class-id>UserArray class</class-id> <category>instance creation</category><body package="model" selector="getInstance">getInstance	"Search an instance of UserArray and create it if not exist"		((UserArray classInstance) = nil) ifTrue: [		UserArray classInstance: (UserArray new: 10).		].		^(UserArray classInstance)</body></methods><methods><class-id>UserArray</class-id> <category>adding</category><body package="model" selector="add:">add: anObject	| i |	i := self indexOf: nil	</body></methods><methods><class-id>UserArray</class-id> <category>adding</category><body package="model" selector="add:">add: anObject	| i |	i := self indexOf: nil.	i isNil ifFalse: [		self at: i put: anObject.	].</body></methods><do-it>c := UserArray getInstance.</do-it><do-it>c</do-it><methods><class-id>UserArray class</class-id> <category>instance creation</category><body package="model" selector="getInstance">getInstance	"Search an instance of UserArray and create it if not exist"		UserArray classInstance isNil ifTrue: [		UserArray classInstance: (UserArray new: 10).		].		^(UserArray classInstance)</body></methods><do-it>c := UserArray getInstance.</do-it><do-it>c</do-it><do-it>c := UserArray new: 10.</do-it><do-it>c</do-it><remove-selector><class-id>UserArray class</class-id> <selector>getInstance</selector></remove-selector><do-it>UserArray class organization removeCategory: #'instance creation'</do-it><class><name>ManageUserController</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>users </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>controller</package></attributes></class><methods><class-id>ManageUserController</class-id> <category>accessing</category><body package="controller" selector="users">users	^users</body></methods><methods><class-id>ManageUserController</class-id> <category>accessing</category><body package="controller" selector="users:">users: anObject	users := anObject</body></methods><methods><class-id>ManageUserController</class-id> <category>controlling</category><body package="controller" selector="addUser:">addUser: userName	"Add the user to the UserArray"		self users add: userName.</body></methods><methods><class-id>ManageUserController</class-id> <category>initialize-release</category><body package="controller" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	self users = UserArray new: 10.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>ManageUserController</class-id> <category>initialize-release</category><body package="controller" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	self users = UserArray new.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>ManageUserController</class-id> <category>initialize-release</category><body package="controller" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	self users: UserArray new.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><do-it>c := ManageUserController new.</do-it><do-it>c</do-it><do-it>new</do-it><do-it>c := ManageUserController new.</do-it><do-it>c</do-it><do-it>new</do-it><do-it>c := ManageUserController new.</do-it><do-it>c := ManageUserController new.</do-it><do-it>c</do-it><methods><class-id>ManageUserController class</class-id> <category>instance creation</category><body package="controller" selector="new">new	"Answer a newly created and initialized instance."	| c |	c := super new initialize.		^c</body></methods><methods><class-id>ManageUserController class</class-id> <category>instance creation</category><body package="controller" selector="new">new	"Answer a newly created and initialized instance."	| c |	c := super new initialize.	c users: UserArray new: 10.	^c</body></methods><methods><class-id>ManageUserController class</class-id> <category>instance creation</category><body package="controller" selector="new">new	"Answer a newly created and initialized instance."	| c |	c := super new initialize.	^c</body></methods><do-it>c := ManageUserController new.</do-it><do-it>c</do-it><methods><class-id>ManageUserController class</class-id> <category>instance creation</category><body package="controller" selector="new">new	"Answer a newly created and initialized instance."	| c |	c := super new initialize.	c users: (UserArray new: 10).		^c</body></methods><do-it>c := ManageUserController new.</do-it><do-it>c</do-it><do-it>UserArray class organization addCategory: #'instance creation'</do-it><methods><class-id>UserArray class</class-id> <category>instance creation</category><body package="model" selector="getInstance">getInstance	(UserArray classInstance isNil) ifTrue: [		UserArray classInstance: (UserArray new: 10).		].</body></methods><methods><class-id>UserArray class</class-id> <category>instance creation</category><body package="model" selector="getInstance">getInstance	(UserArray classInstance isNil) ifTrue: [		UserArray classInstance: (UserArray new: 10).		].		^UserArray classInstance.</body></methods><methods><class-id>UserArray class</class-id> <category>instance creation</category><body package="model" selector="getInstance">getInstance	(UserArray classInstance isNil) ifTrue: [		UserArray classInstance: (UserArray new: 10).		].		^UserArray classInstance</body></methods><methods><class-id>ManageUserController class</class-id> <category>instance creation</category><body package="controller" selector="new">new	"Answer a newly created and initialized instance."	| c |	c := super new initialize.	c users: (UserArray getInstance).		^c</body></methods><methods><class-id>UserArray class</class-id> <category>instance creation</category><body package="model" selector="getInstance">getInstance	(UserArray classInstance isNil) ifTrue: [		UserArray classInstance: (UserArray new: 10).	].	(UserArray classInstance size = 0) ifTrue: [		UserArray classInstance: (UserArray new: 10).	].		^UserArray classInstance</body></methods><do-it>c := UserArray getInstance.</do-it><do-it>c</do-it><methods><class-id>ManageUserController</class-id> <category>controlling</category><body package="controller" selector="updateUserList">updateUserList</body></methods><methods><class-id>ManageUserController</class-id> <category>controlling</category><body package="controller" selector="addUser:">addUser: userName	"Add the user to the UserArray"		self users add: userName.	self updateUserList.</body></methods><do-it>Dialog    choose: 'Which one do you want?'    fromList: #('first' 'second' 'third' 'fourth')    values: #(1 2 3 4)    lines: 8    cancel: [#noChoice]</do-it><do-it>Dialog    choose: 'Which one do you want?'    fromList: #('first' 'second' 'third' 'fourth')    values: #(1 2 3 4)    lines: 8    cancel: [#noChoice]</do-it><methods><class-id>UserArray</class-id> <category>adding</category><body package="model" selector="add:">add: anObject	| i |	i := self indexOf: nil.	(i = -1) ifFalse: [		self at: i put: anObject.	].</body></methods><do-it>self indexOf: nil</do-it><methods><class-id>UserArray</class-id> <category>adding</category><body package="model" selector="add:">add: anObject	| i |	i := self indexOf: nil.	(i = 0) ifFalse: [		self at: i put: anObject.	].</body></methods><methods><class-id>UserArray</class-id> <category>adding</category><body package="model" selector="add:">add: anObject	| i b |	i := self indexOf: nil.	b := self indexOf: anObject.	((i = 0) &amp; (b = 0)) ifFalse: [		self at: i put: anObject.	].</body></methods><methods><class-id>UserArray</class-id> <category>adding</category><body package="model" selector="add:">add: anObject	| i b |	i := self indexOf: nil.	b := self indexOf: anObject.	((i = 0) &amp; (b ~= 0)) ifFalse: [		self at: i put: anObject.	].</body></methods><methods><class-id>ManageUserInterface class</class-id> <category>interface specs</category><body package="view" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Manage users' 			#bounds: #(#{Graphics.Rectangle} 871 714 1160 946 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 18 0 16 0 154 0 180 0 ) 					#name: #userList 					#model: #userList 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 23 0 199 0 75 0 220 0 ) 					#name: #removeUser 					#model: #removeUser 					#label: 'Remove' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 222 0 53 0 274 0 74 0 ) 					#name: #addUser 					#model: #addUser 					#label: 'Add' 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 177 0 17 0 277 0 42 0 ) 					#name: #userName 					#model: #userName ) ) ) )</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/kevin/VisualWorks Projects/ProjetInfo606/ProjetInfo606.im' 'January 27, 2021' '7:13:28 PM')""An image file /home/kevin/VisualWorks Projects/ProjetInfo606/ProjetInfo606.im was created at 19:13:28 on 27 janvier 2021."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/kevin/VisualWorks Projects/ProjetInfo606/ProjetInfo606.im' 'January 27, 2021' '7:13:30 PM')""An image file /home/kevin/VisualWorks Projects/ProjetInfo606/ProjetInfo606.im was created at 19:13:30 on 27 janvier 2021."</do-it><methods><class-id>ManageUserInterface class</class-id> <category>interface specs</category><body package="view" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Manage users' 			#bounds: #(#{Graphics.Rectangle} 816 448 1105 680 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 18 0 16 0 154 0 180 0 ) 					#name: #userList 					#model: #userList 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 23 0 199 0 75 0 220 0 ) 					#name: #removeUser 					#model: #removeUser 					#label: 'Remove' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 222 0 53 0 274 0 74 0 ) 					#name: #addUser 					#model: #addUser 					#label: 'Add' 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 177 0 17 0 277 0 42 0 ) 					#name: #userName 					#model: #userName ) ) ) )</body></methods><methods><class-id>ManageUserInterface class</class-id> <category>interface specs</category><body package="view" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Manage users' 			#bounds: #(#{Graphics.Rectangle} 827 473 1116 705 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 18 0 16 0 154 0 180 0 ) 					#name: #userList 					#model: #userList 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 23 0 199 0 75 0 220 0 ) 					#name: #removeUser 					#model: #removeUser 					#label: 'Remove' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 222 0 53 0 274 0 74 0 ) 					#name: #addUser 					#model: #addUser 					#label: 'Add' 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 177 0 17 0 277 0 42 0 ) 					#name: #userName 					#model: #userName ) ) ) )</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/kevin/VisualWorks Projects/ProjetInfo606/ProjetInfo606.im' 'January 29, 2021' '9:50:01 AM')""An image file /home/kevin/VisualWorks Projects/ProjetInfo606/ProjetInfo606.im was created at 09:50:01 on 29 janvier 2021."</do-it><do-it>c := UserArray getInstance.</do-it><do-it>c</do-it><methods><class-id>ManageUserController</class-id> <category>controlling</category><body package="controller" selector="addUser:">addUser: userName	"Add the user to the UserArray"		self users add: userName.</body></methods><remove-selector><class-id>ManageUserController</class-id> <selector>updateUserList</selector></remove-selector><methods><class-id>ManageUserInterface class</class-id> <category>interface specs</category><body package="view" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Manage users' 			#bounds: #(#{Graphics.Rectangle} 816 448 1105 680 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 18 0 16 0 154 0 180 0 ) 					#name: #userList 					#model: #userList 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 23 0 199 0 75 0 220 0 ) 					#name: #removeUser 					#model: #removeUser 					#label: 'Remove' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 222 0 53 0 274 0 74 0 ) 					#name: #addUser 					#model: #addUser 					#label: 'Add' 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 177 0 17 0 277 0 42 0 ) 					#name: #userName 					#model: #userName ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 227 0 198 0 279 0 219 0 ) 					#name: #OKButton 					#label: 'OK' 					#defaultable: true ) ) ) )</body></methods><methods><class-id>ChoiceUserInterface class</class-id> <category>interface specs</category><body package="view" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Choice user' 			#bounds: #(#{Graphics.Rectangle} 828 551 1118 610 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 12 0 17 0 148 0 38 0 ) 					#name: #UserChoice 					#label: 					#(#{Kernel.UserMessage} 						#key: nil 						#defaultString: 'UserChoice' 						#catalogID: #'UserArray searchAndCreate' ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 181 0 17 0 264 0 38 0 ) 					#name: #ManageButton 					#label: 'Manage users' 					#isDefault: false 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 11 0 56 0 63 0 77 0 ) 					#name: #OKButton 					#label: 'OK' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 72 0 56 0 124 0 77 0 ) 					#name: #CancelButton1 					#label: 'Cancel' 					#defaultable: true ) ) ) )</body></methods><methods><class-id>ManageUserInterface class</class-id> <category>interface specs</category><body package="view" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Manage users' 			#bounds: #(#{Graphics.Rectangle} 816 477 1105 709 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 18 0 16 0 154 0 180 0 ) 					#name: #userList 					#model: #userList 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #onChangeUserList ) 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 23 0 199 0 75 0 220 0 ) 					#name: #removeUser 					#model: #removeUser 					#label: 'Remove' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 222 0 53 0 274 0 74 0 ) 					#name: #addUser 					#model: #addUser 					#label: 'Add' 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 177 0 17 0 277 0 42 0 ) 					#name: #userName 					#model: #userName ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 227 0 198 0 279 0 219 0 ) 					#name: #OKButton 					#label: 'OK' 					#defaultable: true ) ) ) )</body></methods><class><name>ManageUserInterface</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>userName userList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>view</package></attributes></class><do-it>Smalltalk defineClass: #ManageUserInterface	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'userName userList  '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>ManageUserInterface</class-id> <category>aspects</category><body package="view" selector="userList">userList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^userList isNil		ifTrue:			[userList := SelectionInList new]		ifFalse:			[userList]</body></methods><class><name>ManageUserInterface</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>userName userList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>view</package></attributes></class><do-it>Smalltalk defineClass: #ManageUserInterface	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'userName userList  '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>ManageUserInterface</class-id> <category>aspects</category><body package="view" selector="userList">userList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^userList isNil		ifTrue:			[userList := SelectionInList new]		ifFalse:			[userList]</body></methods><methods><class-id>ManageUserInterface class</class-id> <category>interface specs</category><body package="view" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Manage users' 			#bounds: #(#{Graphics.Rectangle} 816 477 1105 709 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 18 0 16 0 154 0 180 0 ) 					#name: #userList 					#model: #userList 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #onChangeUserList ) 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 23 0 199 0 75 0 220 0 ) 					#name: #removeUser 					#model: #removeUser 					#label: 'Remove' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 222 0 53 0 274 0 74 0 ) 					#name: #addUser 					#model: #addUser 					#label: 'Add' 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 177 0 17 0 277 0 42 0 ) 					#name: #userName 					#model: #userName ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 227 0 198 0 279 0 219 0 ) 					#name: #OKButton 					#label: 'OK' 					#defaultable: true ) ) ) )</body></methods><do-it>ManageUserInterface organization addCategory: #changing</do-it><methods><class-id>ManageUserInterface</class-id> <category>changing</category><body package="view" selector="onChangeUserList">onChangeUserList</body></methods><do-it>ManageUserController</do-it><do-it>ManageUserController class</do-it><do-it>Object class</do-it><do-it>ManageUserInterface class</do-it><do-it>ManageUserController class</do-it><comment><class-id>ManageUserController</class-id><body>ManageUserController has not been commented.  The comment should state the purpose of the class and also explain any unobvious aspects of the implementation.users</body></comment><comment><class-id>ManageUserController</class-id><body>ManageUserController has not been commented.  The comment should state the purpose of the class and also explain any unobvious aspects of the implementation.</body></comment><do-it>SelectionInList</do-it><methods><class-id>ManageUserInterface</class-id> <category>actions</category><body package="view" selector="removeUser">removeUser	"This stub method was generated by UIDefiner"	| c |		^self</body></methods><methods><class-id>ManageUserController</class-id> <category>controlling</category><body package="controller" selector="removeUser:">removeUser: aUser</body></methods><methods><class-id>ManageUserController</class-id> <category>controlling</category><body package="controller" selector="removeUser:">removeUser: Username</body></methods><methods><class-id>ManageUserController</class-id> <category>controlling</category><body package="controller" selector="removeUser:">removeUser: userName</body></methods><methods><class-id>ManageUserInterface</class-id> <category>actions</category><body package="view" selector="removeUser">removeUser	"This stub method was generated by UIDefiner"	| c |	c := ManageUserController new.	c removeUser: userList selection.	^self</body></methods><methods><class-id>ManageUserInterface</class-id> <category>actions</category><body package="view" selector="removeUser">removeUser	"This stub method was generated by UIDefiner"	| c |	c := ManageUserController new.	c removeUser: userList selection.</body></methods><methods><class-id>ManageUserController</class-id> <category>controlling</category><body package="controller" selector="removeUser:">removeUser: userName	"Remove the user to the UserArray"</body></methods><methods><class-id>ManageUserController</class-id> <category>controlling</category><body package="controller" selector="removeUser:">removeUser: userName	"Remove the user to the UserArray"		self users remove: userName</body></methods><do-it>UserArray organization addCategory: #removing</do-it><methods><class-id>UserArray</class-id> <category>removing</category><body package="model" selector="remove:">remove: userName</body></methods><methods><class-id>UserArray</class-id> <category>removing</category><body package="model" selector="remove:">remove: userName	| i b |	</body></methods><methods><class-id>UserArray</class-id> <category>removing</category><body package="model" selector="remove:">remove: userName	| i |	i := self indexOf: userName.	(i = 0) ifFalse: [		self at: i put: nil.	].</body></methods><do-it>ManageUserInterface organization addCategory: #'initialize-release'</do-it><methods><class-id>ManageUserInterface</class-id> <category>initialize-release</category><body package="view" selector="initialize">initialize	</body></methods><methods><class-id>ManageUserInterface</class-id> <category>initialize-release</category><body package="view" selector="initialize">initialize	self userList list: UserArray getInstance.</body></methods><class><name>ManageUserInterface</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>userName userList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>view</package></attributes></class><do-it>Smalltalk defineClass: #ManageUserInterface	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'userName userList  '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>ManageUserInterface</class-id> <category>actions</category><body package="view" selector="OKButton">OKButton	"This stub method was generated by UIDefiner"	^self</body></methods><methods><class-id>ManageUserInterface class</class-id> <category>interface specs</category><body package="view" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Manage users' 			#bounds: #(#{Graphics.Rectangle} 816 477 1105 709 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 18 0 16 0 154 0 180 0 ) 					#name: #userList 					#model: #userList 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #onChangeUserList ) 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 23 0 199 0 75 0 220 0 ) 					#name: #removeUser 					#model: #removeUser 					#label: 'Remove' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 222 0 53 0 274 0 74 0 ) 					#name: #addUser 					#model: #addUser 					#label: 'Add' 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 177 0 17 0 277 0 42 0 ) 					#name: #userName 					#model: #userName ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 227 0 198 0 279 0 219 0 ) 					#name: #OKButton 					#model: #OKButton 					#label: 'OK' 					#defaultable: true ) ) ) )</body></methods><methods><class-id>ManageUserInterface</class-id> <category>actions</category><body package="view" selector="OKButton">OKButton	"Close the window"	^self</body></methods><do-it>UI.ApplicationModel</do-it><methods><class-id>ChoiceUserInterface class</class-id> <category>interface specs</category><body package="view" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Choice user' 			#bounds: #(#{Graphics.Rectangle} 815 583 1105 642 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 12 0 17 0 148 0 38 0 ) 					#name: #UserChoice 					#label: 					#(#{Kernel.UserMessage} 						#key: nil 						#defaultString: 'UserChoice' 						#catalogID: #'UserArray searchAndCreate' ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 181 0 17 0 264 0 38 0 ) 					#name: #ManageButton 					#label: 'Manage users' 					#isDefault: false 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 11 0 56 0 63 0 77 0 ) 					#name: #OKButton 					#label: 'OK' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 72 0 56 0 124 0 77 0 ) 					#name: #CancelButton1 					#label: 'Cancel' 					#defaultable: true ) ) ) )</body></methods><class><name>ChoiceUserInterface</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>view</package></attributes></class><do-it>Smalltalk defineClass: #ChoiceUserInterface	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: ' '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>ChoiceUserInterface</class-id> <category>actions</category><body package="view" selector="OKButton">OKButton	"This stub method was generated by UIDefiner"	^self</body></methods><methods><class-id>ChoiceUserInterface</class-id> <category>actions</category><body package="view" selector="CancelButton">CancelButton	"This stub method was generated by UIDefiner"	^self</body></methods><methods><class-id>ChoiceUserInterface</class-id> <category>actions</category><body package="view" selector="manageUser">manageUser	"This stub method was generated by UIDefiner"	^self</body></methods><methods><class-id>ChoiceUserInterface class</class-id> <category>interface specs</category><body package="view" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Choice user' 			#bounds: #(#{Graphics.Rectangle} 828 583 1118 642 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 12 0 17 0 148 0 38 0 ) 					#name: #UserChoice 					#label: 					#(#{Kernel.UserMessage} 						#key: nil 						#defaultString: 'UserChoice' 						#catalogID: #'UserArray searchAndCreate' ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 181 0 17 0 264 0 38 0 ) 					#name: #ManageButton 					#model: #manageUser 					#label: 'Manage users' 					#isDefault: false 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 11 0 56 0 63 0 77 0 ) 					#name: #OKButton 					#model: #OKButton 					#label: 'OK' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 72 0 56 0 124 0 77 0 ) 					#name: #CancelButton 					#model: #CancelButton 					#label: 'Cancel' 					#defaultable: true ) ) ) )</body></methods><methods><class-id>ChoiceUserInterface</class-id> <category>actions</category><body package="view" selector="manageUser">manageUser	"Open the ManageUserInterface"</body></methods><methods><class-id>ChoiceUserInterface</class-id> <category>actions</category><body package="view" selector="manageUser">manageUser	"Open the ManageUserInterface"	ManageUserInterface new open.</body></methods><methods><class-id>ChoiceUserInterface class</class-id> <category>interface specs</category><body package="view" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Choice user' 			#min: #(#{Core.Point} 20 20 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 815 588 1105 688 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 12 0 17 0 148 0 38 0 ) 					#name: #UserChoice 					#label: 					#(#{Kernel.UserMessage} 						#key: nil 						#defaultString: 'UserChoice' 						#catalogID: #'UserArray searchAndCreate' ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 181 0 17 0 264 0 38 0 ) 					#name: #ManageButton 					#model: #manageUser 					#label: 'Manage users' 					#isDefault: false 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 11 0 56 0 63 0 77 0 ) 					#name: #OKButton 					#model: #OKButton 					#label: 'OK' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 72 0 56 0 124 0 77 0 ) 					#name: #CancelButton 					#model: #CancelButton 					#label: 'Cancel' 					#defaultable: true ) ) ) )</body></methods><methods><class-id>ManageUserInterface</class-id> <category>actions</category><body package="view" selector="OKButton">OKButton	"Close the window"		^self</body></methods><methods><class-id>ManageUserInterface</class-id> <category>actions</category><body package="view" selector="OKButton">OKButton	"Close the window"	self mainWindow stop.	^self</body></methods><methods><class-id>ManageUserInterface</class-id> <category>actions</category><body package="view" selector="OKButton">OKButton	"Close the window"		^self</body></methods><class><name>ChoiceUserInterface</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>view</package></attributes></class><do-it>Smalltalk defineClass: #ChoiceUserInterface	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: ' '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>ChoiceUserInterface class</class-id> <category>interface specs</category><body package="view" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Choice user' 			#min: #(#{Core.Point} 20 20 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 815 588 1105 688 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 12 0 17 0 148 0 38 0 ) 					#name: #UserChoice 					#label: 					#(#{Kernel.UserMessage} 						#key: nil 						#defaultString: 'UserChoice' 						#catalogID: #'UserArray searchAndCreate' ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 181 0 17 0 264 0 38 0 ) 					#name: #ManageButton 					#model: #manageUser 					#label: 'Manage users' 					#isDefault: false 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 11 0 56 0 63 0 77 0 ) 					#name: #OKButton 					#model: #OKButton 					#label: 'OK' 					#defaultable: true ) ) ) )</body></methods><do-it>ChoiceUserInterface organization addCategory: #'initialize-release'</do-it><class><name>ChoiceUserInterface</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>userChoice </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>view</package></attributes></class><do-it>Smalltalk defineClass: #ChoiceUserInterface	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: ' userChoice '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>ChoiceUserInterface</class-id> <category>aspects</category><body package="view" selector="userChoice">userChoice	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^userChoice isNil		ifTrue:			[userChoice := nil asValue]		ifFalse:			[userChoice]</body></methods><methods><class-id>ChoiceUserInterface</class-id> <category>initialize-release</category><body package="view" selector="initialize">initialize	self userChoice list: UserArray getInstance.</body></methods><class><name>UserArray</name><environment>Smalltalk</environment><super>Core.Array</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>currentUser </inst-vars><class-inst-vars>classInstance </class-inst-vars><imports></imports><category></category><attributes><package>model</package></attributes></class><methods><class-id>UserArray</class-id> <category>accessing</category><body package="model" selector="currentUser">currentUser	^currentUser</body></methods><methods><class-id>UserArray</class-id> <category>accessing</category><body package="model" selector="currentUser:">currentUser: anObject	currentUser := anObject</body></methods><methods><class-id>UserArray</class-id> <category>initialize-release</category><body package="model" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	self currentUser: (self at: 1).	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>ChoiceUserInterface</class-id> <category>initialize-release</category><body package="view" selector="initialize">initialize	self userChoice list: (UserArray getInstance).	self userChoice selection: (UserArray getInstance currentUser).</body></methods><methods><class-id>ManageUserInterface</class-id> <category>actions</category><body package="view" selector="OKButton">OKButton	"Close the window"	self closeRequest.	^self</body></methods><methods><class-id>ChoiceUserInterface</class-id> <category>actions</category><body package="view" selector="OKButton">OKButton	"Close the window"	self closeRequest.	^self</body></methods><methods><class-id>ChoiceUserInterface</class-id> <category>initialize-release</category><body package="view" selector="initialize">initialize	self userChoice selection: (UserArray getInstance currentUser).</body></methods><methods><class-id>ChoiceUserInterface</class-id> <category>initialize-release</category><body package="view" selector="initialize">initialize</body></methods><methods><class-id>ChoiceUserInterface</class-id> <category>initialize-release</category><body package="view" selector="initialize">initialize	self userChoice withAll: UserArray getInstance.</body></methods><methods><class-id>ChoiceUserInterface</class-id> <category>initialize-release</category><body package="view" selector="initialize">initialize	self userChoice.</body></methods><methods><class-id>ChoiceUserInterface class</class-id> <category>interface specs</category><body package="view" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Choice user' 			#min: #(#{Core.Point} 20 20 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 808 586 1098 686 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 178 0 14 0 261 0 35 0 ) 					#name: #ManageButton 					#model: #manageUser 					#label: 'Manage users' 					#isDefault: false 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 11 0 56 0 63 0 77 0 ) 					#name: #OKButton 					#model: #OKButton 					#label: 'OK' 					#defaultable: true ) 				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 7 0 13 0 107 0 38 0 ) 					#name: #userChoice 					#model: #userChoice ) ) ) )</body></methods><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/kevin/VisualWorks Projects/ProjetInfo606/ProjetInfo606.im' 'February 4, 2021' '4:52:41 PM')""An image file /home/kevin/VisualWorks Projects/ProjetInfo606/ProjetInfo606.im was created at 16:52:41 on 4 fvrier 2021."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/kevin/VisualWorks Projects/ProjetInfo606/ProjetInfo606.im' 'February 4, 2021' '4:52:45 PM')""An image file /home/kevin/VisualWorks Projects/ProjetInfo606/ProjetInfo606.im was created at 16:52:45 on 4 fvrier 2021."</do-it><methods><class-id>ChoiceUserInterface</class-id> <category>initialize-release</category><body package="view" selector="initialize">initialize	self userChoice list: UserArray getInstance.</body></methods><methods><class-id>ChoiceUserInterface</class-id> <category>initialize-release</category><body package="view" selector="initialize">initialize</body></methods><methods><class-id>ChoiceUserInterface</class-id> <category>initialize-release</category><body package="view" selector="initialize">initialize	self userChoice.</body></methods><methods><class-id>ChoiceUserInterface class</class-id> <category>interface specs</category><body package="view" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Choice user' 			#min: #(#{Core.Point} 20 20 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 828 599 1118 699 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 178 0 14 0 261 0 35 0 ) 					#name: #ManageButton 					#model: #manageUser 					#label: 'Manage users' 					#isDefault: false 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 11 0 56 0 63 0 77 0 ) 					#name: #OKButton 					#model: #OKButton 					#label: 'OK' 					#defaultable: true ) 				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 7 0 13 0 107 0 38 0 ) 					#name: #userChoice 					#model: #userChoice ) ) ) )</body></methods><remove-selector><class-id>Core.Class</class-id> <selector>user:</selector></remove-selector><remove-selector><class-id>Core.Class</class-id> <selector>user</selector></remove-selector><class><name>Class</name><environment>Core</environment><super>Core.ClassDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name classPool environment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><methods><class-id>Core.Class class</class-id> <category>accessing</category><body package="Kernel-Classes" selector="date">date	^date</body></methods><methods><class-id>Core.Class class</class-id> <category>accessing</category><body package="Kernel-Classes" selector="date:">date: anObject	date := anObject</body></methods><methods><class-id>Core.Class class</class-id> <category>accessing</category><body package="Kernel-Classes" selector="user">user	^user</body></methods><methods><class-id>Core.Class class</class-id> <category>accessing</category><body package="Kernel-Classes" selector="user:">user: anObject	user := anObject</body></methods><methods><class-id>ChoiceUserInterface</class-id> <category>initialize-release</category><body package="view" selector="initialize">initialize	self userChoice = UserArray getInstance asValue.</body></methods><methods><class-id>ChoiceUserInterface</class-id> <category>initialize-release</category><body package="view" selector="initialize">initialize	self userChoice. "UserArray getInstance asValue."</body></methods><class><name>ChoiceUserInterface</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>userChoice userChoices </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>view</package></attributes></class><do-it>Smalltalk defineClass: #ChoiceUserInterface	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'userChoice  userChoices '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>ChoiceUserInterface</class-id> <category>aspects</category><body package="view" selector="userChoices">userChoices	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^userChoices isNil		ifTrue:			[userChoices := List new asValue]		ifFalse:			[userChoices]</body></methods><methods><class-id>ChoiceUserInterface</class-id> <category>aspects</category><body package="view" selector="userChoice">userChoice	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^userChoice isNil		ifTrue:			[userChoice := String new asValue]		ifFalse:			[userChoice]</body></methods><methods><class-id>ChoiceUserInterface class</class-id> <category>interface specs</category><body package="view" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Choice user' 			#min: #(#{Core.Point} 20 20 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 815 514 1105 614 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 178 0 14 0 261 0 35 0 ) 					#name: #ManageButton 					#model: #manageUser 					#label: 'Manage users' 					#isDefault: false 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 11 0 56 0 63 0 77 0 ) 					#name: #OKButton 					#model: #OKButton 					#label: 'OK' 					#defaultable: true ) 				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 7 0 13 0 107 0 38 0 ) 					#name: #userChoice 					#model: #userChoice 					#comboList: #userChoices ) ) ) )</body></methods><methods><class-id>ChoiceUserInterface</class-id> <category>initialize-release</category><body package="view" selector="initialize">initialize	userChoices := UserArray getInstance asValue.</body></methods><methods><class-id>ChoiceUserInterface</class-id> <category>actions</category><body package="view" selector="OKButton">OKButton	"Close the window"	UserArray getInstance currentUser: userChoice.	self closeRequest.	^self</body></methods><do-it>c := UserArray getInstance.</do-it><do-it>c := UserArray getInstance.</do-it><do-it>c := UserArray getInstance.</do-it><do-it>c</do-it><methods><class-id>ChoiceUserInterface</class-id> <category>actions</category><body package="view" selector="OKButton">OKButton	"Close the window"	UserArray getInstance currentUser: userChoice asValue.	self closeRequest.	^self</body></methods><methods><class-id>ChoiceUserInterface</class-id> <category>actions</category><body package="view" selector="OKButton">OKButton	"Close the window"	UserArray getInstance currentUser: userChoice value.	self closeRequest.	^self</body></methods><do-it>Object</do-it><do-it>Class class</do-it><do-it>Class class</do-it><do-it>Smalltalk</do-it><do-it>Class class</do-it><do-it>Smalltalk</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/kevin/VisualWorks Projects/ProjetInfo606/ProjetInfo606.im' 'February 8, 2021' '2:48:56 PM')""An image file /home/kevin/VisualWorks Projects/ProjetInfo606/ProjetInfo606.im was created at 14:48:56 on 8 fvrier 2021."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/kevin/VisualWorks Projects/ProjetInfo606/ProjetInfo606.im' 'February 8, 2021' '2:48:59 PM')""An image file /home/kevin/VisualWorks Projects/ProjetInfo606/ProjetInfo606.im was created at 14:48:59 on 8 fvrier 2021."</do-it><do-it>UserArray</do-it><do-it>UserArray class</do-it><do-it>UserArray class</do-it><do-it>c</do-it><do-it>Class class</do-it><do-it>UserArray class.</do-it><do-it>UserArray</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/kevin/VisualWorks Projects/ProjetInfo606/ProjetInfo606.im' 'February 8, 2021' '4:46:43 PM')""An image file /home/kevin/VisualWorks Projects/ProjetInfo606/ProjetInfo606.im was created at 16:46:43 on 8 fvrier 2021."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/kevin/VisualWorks Projects/ProjetInfo606/ProjetInfo606.im' 'February 8, 2021' '4:56:52 PM')""An image file /home/kevin/VisualWorks Projects/ProjetInfo606/ProjetInfo606.im was created at 16:56:52 on 8 fvrier 2021."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/kevin/VisualWorks Projects/ProjetInfo606/ProjetInfo606.im' 'February 9, 2021' '6:04:22 PM')""An image file /home/kevin/VisualWorks Projects/ProjetInfo606/ProjetInfo606.im was created at 18:04:22 on 9 fvrier 2021."</do-it><do-it>UserArray class.</do-it><remove-selector><class-id>Core.Class class</class-id> <selector>date</selector></remove-selector><remove-selector><class-id>Core.Class class</class-id> <selector>user:</selector></remove-selector><remove-selector><class-id>Core.Class class</class-id> <selector>user</selector></remove-selector><remove-selector><class-id>Core.Class class</class-id> <selector>date:</selector></remove-selector><do-it>Class class organization removeCategory: #accessing</do-it><do-it>Class class.</do-it><class><name>Metaclass</name><environment>Core</environment><super>Core.ClassDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>thisClass author </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>Metaclass</name><environment>Core</environment><super>Core.ClassDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>thisClass author createdAt </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><do-it>Metaclass class organization addCategory: #accessing</do-it><do-it>Metaclass class organization removeCategory: #accessing</do-it><methods><class-id>Core.Metaclass</class-id> <category>accessing</category><body package="Kernel-Classes" selector="author">author	^author</body></methods><methods><class-id>Core.Metaclass</class-id> <category>accessing</category><body package="Kernel-Classes" selector="author:">author: anObject	author := anObject</body></methods><methods><class-id>Core.Metaclass</class-id> <category>accessing</category><body package="Kernel-Classes" selector="createdAt">createdAt	^createdAt</body></methods><methods><class-id>Core.Metaclass</class-id> <category>accessing</category><body package="Kernel-Classes" selector="createdAt:">createdAt: anObject	createdAt := anObject</body></methods><remove-selector><class-id>Core.Metaclass</class-id> <selector>createdAt:</selector></remove-selector><remove-selector><class-id>Core.Metaclass</class-id> <selector>author:</selector></remove-selector><do-it>t := Array new.</do-it><comment><class-id>Core.Metaclass</class-id><body>Metaclasses add instance-specific behavior to various classes in the system.  This typically includes messages for initializing class variables and instance creation messages particular to that class.  There is only one instance of a metaclass, namely the class (thisClass) that is being described.  A metaclass shares the class variables of its instance.[Subtle] In general, the superclass hierarchy for metaclasses parallels that for classes.  Thus,	Integer superclass == Number, and	Integer class superclass == Number class.However there is a singularity at Object.  Here the class hierarchy terminates, but the metaclass hierarchy must wrap around to Class, since ALL metaclasses are subclasses of Class.  Thus,	Object superclass == nil, and	Object class superclass == Class.Instance Variables:	thisClass	&lt;Class&gt; the chief instance of the receiver, which the receiver describes	author         &lt;String&gt; the author of the class	createdAt    &lt;Date&gt; the date of creation of the classClass Variables:	ObsoleteSignal 	&lt;Signal&gt; Obsolete metaclass		</body></comment><do-it>UserArray getInstance currentUser.</do-it><methods><class-id>Core.Metaclass</class-id> <category>instance creation</category><body package="Kernel-Classes" selector="new">new	"The receiver can only have one instance.  Create it or complain that	one already exists."	| c |	thisClass == nil		ifTrue: [			c := super new.							^thisClass := super new		]		ifFalse: [self error: (#ErrorMetaclassShouldOnlyHaveOneInstance &lt;&lt; #dialogs &gt;&gt; 'A Metaclass should only have one instance!')]</body></methods><methods><class-id>Core.Metaclass</class-id> <category>instance creation</category><body package="Kernel-Classes" selector="new">new	"The receiver can only have one instance.  Create it or complain that	one already exists."	| c |	thisClass == nil		ifTrue: [			c := super new.					^thisClass := super new		]		ifFalse: [self error: (#ErrorMetaclassShouldOnlyHaveOneInstance &lt;&lt; #dialogs &gt;&gt; 'A Metaclass should only have one instance!')]</body></methods><methods><class-id>Core.Metaclass</class-id> <category>accessing</category><body package="Kernel-Classes" selector="author:">author: anObject	author := anObject</body></methods><methods><class-id>Core.Metaclass</class-id> <category>accessing</category><body package="Kernel-Classes" selector="createdAt:">createdAt: anObject	createdAt := anObject</body></methods><methods><class-id>Core.Metaclass</class-id> <category>instance creation</category><body package="Kernel-Classes" selector="new">new	"The receiver can only have one instance.  Create it or complain that	one already exists."	| c |	thisClass == nil		ifTrue: [			c := super new.				c author: UserArray getInstance currentUser.			^thisClass := super new		]		ifFalse: [self error: (#ErrorMetaclassShouldOnlyHaveOneInstance &lt;&lt; #dialogs &gt;&gt; 'A Metaclass should only have one instance!')]</body></methods><methods><class-id>Core.Metaclass</class-id> <category>instance creation</category><body package="Kernel-Classes" selector="new">new	"The receiver can only have one instance.  Create it or complain that	one already exists."	| c |	thisClass == nil		ifTrue: [			c := super new.				c author: UserArray getInstance currentUser.			c createdAt: Date today.			^thisClass := super new		]		ifFalse: [self error: (#ErrorMetaclassShouldOnlyHaveOneInstance &lt;&lt; #dialogs &gt;&gt; 'A Metaclass should only have one instance!')]</body></methods><methods><class-id>Core.Metaclass</class-id> <category>instance creation</category><body package="Kernel-Classes" selector="new">new	"The receiver can only have one instance.  Create it or complain that	one already exists."	| c |	thisClass == nil		ifTrue: [			c := super new.				c author: UserArray getInstance currentUser.			c createdAt: Date today.			^c.		]		ifFalse: [self error: (#ErrorMetaclassShouldOnlyHaveOneInstance &lt;&lt; #dialogs &gt;&gt; 'A Metaclass should only have one instance!')]</body></methods><methods><class-id>Core.Metaclass</class-id> <category>instance creation</category><body package="Kernel-Classes" selector="new">new	"The receiver can only have one instance.  Create it or complain that	one already exists."	| c |	thisClass == nil		ifTrue: [			c := super new.				c author: UserArray getInstance currentUser.			c createdAt: Date today.			thisClass := c.			^c.		]		ifFalse: [self error: (#ErrorMetaclassShouldOnlyHaveOneInstance &lt;&lt; #dialogs &gt;&gt; 'A Metaclass should only have one instance!')]</body></methods><methods><class-id>Core.Metaclass</class-id> <category>instance creation</category><body package="Kernel-Classes" selector="new">new	"The receiver can only have one instance.  Create it or complain that	one already exists."	| c |	thisClass == nil		ifTrue: [			"c := super new.				c author: UserArray getInstance currentUser.			c createdAt: Date today."			^thisClass := c.			"^c."		]		ifFalse: [self error: (#ErrorMetaclassShouldOnlyHaveOneInstance &lt;&lt; #dialogs &gt;&gt; 'A Metaclass should only have one instance!')]</body></methods><methods><class-id>Core.Metaclass</class-id> <category>instance creation</category><body package="Kernel-Classes" selector="new">new	"The receiver can only have one instance.  Create it or complain that	one already exists."	| c |	thisClass == nil		ifTrue: [			"c := super new.				c author: UserArray getInstance currentUser.			c createdAt: Date today."			^thisClass := super new.			"^c."		]		ifFalse: [self error: (#ErrorMetaclassShouldOnlyHaveOneInstance &lt;&lt; #dialogs &gt;&gt; 'A Metaclass should only have one instance!')]</body></methods><methods><class-id>Core.Metaclass</class-id> <category>instance creation</category><body package="Kernel-Classes" selector="new">new	"The receiver can only have one instance.  Create it or complain that	one already exists."	| c |	thisClass == nil		ifTrue: [			"c := super new.				c author: UserArray getInstance currentUser.			c createdAt: Date today."			^thisClass := super new			"^c."		]		ifFalse: [self error: (#ErrorMetaclassShouldOnlyHaveOneInstance &lt;&lt; #dialogs &gt;&gt; 'A Metaclass should only have one instance!')]</body></methods><class><name>Test</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>controller</package></attributes></class><methods><class-id>Test</class-id> <category>initialize-release</category><body package="controller" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>Test class</class-id> <category>instance creation</category><body package="controller" selector="new">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>Test</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>Test</staticKey> <definitionChange>added</definitionChange></component_static_change><do-it>Test removeFromSystem</do-it><methods><class-id>Core.Metaclass</class-id> <category>instance creation</category><body package="Kernel-Classes" selector="new">new	"The receiver can only have one instance.  Create it or complain that	one already exists."	| c |	thisClass == nil		ifTrue: [			c := super new.				c author: UserArray getInstance currentUser.			c createdAt: Date today.			thisClass := c.			^c		]		ifFalse: [self error: (#ErrorMetaclassShouldOnlyHaveOneInstance &lt;&lt; #dialogs &gt;&gt; 'A Metaclass should only have one instance!')]</body></methods><methods><class-id>Core.Metaclass</class-id> <category>instance creation</category><body package="Kernel-Classes" selector="new">new	"The receiver can only have one instance.  Create it or complain that	one already exists."	| c |	thisClass == nil		ifTrue: [			c := (super new).			c author: (UserArray getInstance currentUser).			c createdAt: (Date today).			thisClass := c.			^c		]		ifFalse: [self error: (#ErrorMetaclassShouldOnlyHaveOneInstance &lt;&lt; #dialogs &gt;&gt; 'A Metaclass should only have one instance!')]</body></methods><methods><class-id>Core.Metaclass</class-id> <category>instance creation</category><body package="Kernel-Classes" selector="new">new	"The receiver can only have one instance.  Create it or complain that	one already exists."	thisClass == nil		ifTrue: [			^thisClass := super new initialize		]		ifFalse: [self error: (#ErrorMetaclassShouldOnlyHaveOneInstance &lt;&lt; #dialogs &gt;&gt; 'A Metaclass should only have one instance!')]</body></methods><methods><class-id>Core.Metaclass</class-id> <category>initialize-release</category><body package="Kernel-Classes" selector="initialize">initialize	super initialize.	self author: (UserArray getInstance currentUser).	self createdAt: (Date today).</body></methods><class><name>Test</name><environment>Smalltalk</environment><super>ManageUserController</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>controller</package></attributes></class><methods><class-id>Test</class-id> <category>initialize-release</category><body package="controller" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><do-it>t := Test new.</do-it><do-it>t</do-it><do-it>t</do-it><do-it>Test removeFromSystem</do-it><class><name>Test</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>controller</package></attributes></class><methods><class-id>Test</class-id> <category>initialize-release</category><body package="controller" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>Test class</class-id> <category>instance creation</category><body package="controller" selector="new">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><comment><class-id>Test</class-id><body>Test has not been commented.  The comment should state the purpose of the class and also explain any unobvious aspects of the implementation.</body></comment><do-it>Test</do-it><do-it>Test class</do-it><do-it>Test removeFromSystem</do-it><class><name>Test</name><environment>Smalltalk</environment><super>Core.Class</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>controller</package></attributes></class><methods><class-id>Test</class-id> <category>initialize-release</category><body package="controller" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>Test class</class-id> <category>instance creation</category><body package="controller" selector="new">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><comment><class-id>Test</class-id><body>Test has not been commented.  The comment should state the purpose of the class and also explain any unobvious aspects of the implementation.</body></comment><do-it>Test class</do-it><do-it>Class class</do-it><remove-selector><class-id>Core.Metaclass</class-id> <selector>initialize</selector></remove-selector><remove-selector><class-id>Core.Metaclass</class-id> <selector>author</selector></remove-selector><remove-selector><class-id>Core.Metaclass</class-id> <selector>author:</selector></remove-selector><remove-selector><class-id>Core.Metaclass</class-id> <selector>createdAt</selector></remove-selector><remove-selector><class-id>Core.Metaclass</class-id> <selector>createdAt:</selector></remove-selector><class><name>Metaclass</name><environment>Core</environment><super>Core.ClassDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>thisClass createdAt </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>Metaclass</name><environment>Core</environment><super>Core.ClassDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>thisClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><do-it>UserArray</do-it><do-it>Array</do-it><do-it>ArrayedCollection</do-it><do-it>SequenceableCollection</do-it><do-it>SequenceableCollection</do-it><do-it>SequenceableCollection</do-it><do-it>Collection</do-it><do-it>Object</do-it><do-it>Object class</do-it><comment><class-id>Core.Class</class-id><body>Instances of class Class describe the representation and behavior of objects.  Class adds more comprehensive programming support facilities to the basic attributes of Behavior and the descriptive facilities of ClassDescription.  An example is accessing shared (pool) variables.Instance Variables:	name		&lt;Symbol&gt; name of class for printing and global reference	classPool	&lt;PoolDictionary | nil&gt; of variables common to all instances	environment	&lt;Namespace | nil&gt; the name space corresponding to this class</body></comment><class><name>Class</name><environment>Core</environment><super>Core.ClassDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name classPool environment </inst-vars><class-inst-vars>author createdAt </class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><comment><class-id>Core.Class</class-id><body>Instances of class Class describe the representation and behavior of objects.  Class adds more comprehensive programming support facilities to the basic attributes of Behavior and the descriptive facilities of ClassDescription.  An example is accessing shared (pool) variables.Instance Variables:	name		&lt;Symbol&gt; name of class for printing and global reference	classPool	&lt;PoolDictionary | nil&gt; of variables common to all instances	environment	&lt;Namespace | nil&gt; the name space corresponding to this classClass Instance Varaibles:	author		&lt;String&gt; name of the author of the class	createdAt	&lt;Date&gt; date of creation of the class	</body></comment><comment><class-id>Core.Class</class-id><body>Instances of class Class describe the representation and behavior of objects.  Class adds more comprehensive programming support facilities to the basic attributes of Behavior and the descriptive facilities of ClassDescription.  An example is accessing shared (pool) variables.Instance Variables:	name		&lt;Symbol&gt; name of class for printing and global reference	classPool	&lt;PoolDictionary | nil&gt; of variables common to all instances	environment	&lt;Namespace | nil&gt; the name space corresponding to this classClass Instance Variables:	author		&lt;String&gt; name of the author of the class	createdAt	&lt;Date&gt; date of creation of the class	</body></comment><methods><class-id>Kernel.NameSpace</class-id> <category>definition</category><body package="System-Name Spaces" selector="defineClass:superclass:indexedType:private:instanceVariableNames:classInstanceVariableNames:imports:category:attributes:author:createdAt:">defineClass: className superclass: superID indexedType: typeName private: isPrivate	instanceVariableNames: iVars classInstanceVariableNames: ciVars	imports: pools category: category attributes: attributes author: author createdAt: createdAt	| superclass approved class cbr mbr |	superID == nil		ifTrue: [superclass := nil]		ifFalse: [(superID binding isForClass				or: [superID binding isForGeneral				and: [superID binding isConstant				and: [superID binding value isBehavior]]])			ifTrue: [superclass := superID value]			ifFalse: [self error: (#SuperclassMustBeAClass &lt;&lt; #dialogs &gt;&gt; 'The superclass of a class must also be a class')]].	Behavior checkLegalBehaviorType: typeName.	approved := SystemUtils			validateClassName: className			for: nil.	approved == nil ifTrue: [^nil].	cbr := (BehaviorBuilderRecord forName: approved in: self)			superclass: superclass;			instVarString: iVars;			category: category;			attributes: attributes;			behaviorType: typeName;			importString: pools;			private: isPrivate.	(mbr := MetaclassBuilderRecord new)		forInstance: cbr;		instVarString: ciVars.	class := ClassBuilder new		addRecord: cbr;		addRecord: mbr;		reviseSystem.	^class</body></methods><methods><class-id>Kernel.NameSpace</class-id> <category>definition</category><body package="System-Name Spaces" selector="defineClass:superclass:indexedType:private:instanceVariableNames:classInstanceVariableNames:imports:category:">defineClass: className superclass: superID indexedType: typeName private: isPrivate	instanceVariableNames: iVars classInstanceVariableNames: ciVars	imports: pools category: category	^self defineClass: className		superclass: superID		indexedType: typeName		private: isPrivate		instanceVariableNames: iVars		classInstanceVariableNames: ciVars		imports: pools		category: category		attributes: #( )		author: UserArray getInstance currentUser		createdAt: Date today</body></methods><methods><class-id>Kernel.NameSpace</class-id> <category>definition</category><body package="System-Name Spaces" selector="defineClass:superclass:indexedType:private:instanceVariableNames:classInstanceVariableNames:imports:category:attributes:">defineClass: className superclass: superID indexedType: typeName private: isPrivate	instanceVariableNames: iVars classInstanceVariableNames: ciVars	imports: pools category: category attributes: attributes	^self defineClass: className		superclass: superID		indexedType: typeName		private: isPrivate		instanceVariableNames: iVars		classInstanceVariableNames: ciVars		imports: pools		category: category		attributes: attributes		author: UserArray getInstance currentUser		createdAt: Date today</body></methods><class><name>Test</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>controller</package></attributes></class><do-it>c := Smalltalk defineClass: #Test superclass: #{Core.Object} indexedType: #none private: false instanceVariableNames: '' classInstanceVariableNames: '' imports: '' category: ''</do-it><do-it>c</do-it><class><name>Test</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>t </class-inst-vars><imports></imports><category></category><attributes><package>controller</package></attributes></class><do-it>c := Smalltalk defineClass: #Test superclass: #{Core.Object} indexedType: #none private: false instanceVariableNames: '' classInstanceVariableNames: 't' imports: '' category: ''</do-it><do-it>c</do-it><do-it>c</do-it><do-it>c new.</do-it><class><name>Test</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>toto </class-inst-vars><imports></imports><category></category><attributes><package>controller</package></attributes></class><do-it>clas := Smalltalk defineClass: #Test superclass: #{Core.Object} indexedType: #none private: false instanceVariableNames: '' classInstanceVariableNames: 'toto' imports: '' category: ''</do-it><do-it>clas</do-it><do-it>clas class</do-it><methods><class-id>Kernel.NameSpace</class-id> <category>definition</category><body package="System-Name Spaces" selector="defineClass:superclass:indexedType:private:instanceVariableNames:classInstanceVariableNames:imports:category:attributes:author:createdAt:">defineClass: className superclass: superID indexedType: typeName private: isPrivate	instanceVariableNames: iVars classInstanceVariableNames: ciVars	imports: pools category: category attributes: attributes author: author createdAt: createdAt	| superclass approved class cbr mbr ci |	superID == nil		ifTrue: [superclass := nil]		ifFalse: [(superID binding isForClass				or: [superID binding isForGeneral				and: [superID binding isConstant				and: [superID binding value isBehavior]]])			ifTrue: [superclass := superID value]			ifFalse: [self error: (#SuperclassMustBeAClass &lt;&lt; #dialogs &gt;&gt; 'The superclass of a class must also be a class')]].	Behavior checkLegalBehaviorType: typeName.	approved := SystemUtils			validateClassName: className			for: nil.	approved == nil ifTrue: [^nil].	cbr := (BehaviorBuilderRecord forName: approved in: self)			superclass: superclass;			instVarString: iVars;			category: category;			attributes: attributes;			behaviorType: typeName;			importString: pools;			private: isPrivate.	ci := Array new: (ciVars size) + 2.		(mbr := MetaclassBuilderRecord new)		forInstance: cbr;		instVarString: ciVars.	class := ClassBuilder new		addRecord: cbr;		addRecord: mbr;		reviseSystem.	^class</body></methods><methods><class-id>Kernel.NameSpace</class-id> <category>definition</category><body package="System-Name Spaces" selector="defineClass:superclass:indexedType:private:instanceVariableNames:classInstanceVariableNames:imports:category:attributes:author:createdAt:">defineClass: className superclass: superID indexedType: typeName private: isPrivate	instanceVariableNames: iVars classInstanceVariableNames: ciVars	imports: pools category: category attributes: attributes author: author createdAt: createdAt	| superclass approved class cbr mbr ci |	superID == nil		ifTrue: [superclass := nil]		ifFalse: [(superID binding isForClass				or: [superID binding isForGeneral				and: [superID binding isConstant				and: [superID binding value isBehavior]]])			ifTrue: [superclass := superID value]			ifFalse: [self error: (#SuperclassMustBeAClass &lt;&lt; #dialogs &gt;&gt; 'The superclass of a class must also be a class')]].	Behavior checkLegalBehaviorType: typeName.	approved := SystemUtils			validateClassName: className			for: nil.	approved == nil ifTrue: [^nil].	cbr := (BehaviorBuilderRecord forName: approved in: self)			superclass: superclass;			instVarString: iVars;			category: category;			attributes: attributes;			behaviorType: typeName;			importString: pools;			private: isPrivate.	ci := Array new: (ciVars size) + 2.		(mbr := MetaclassBuilderRecord new)		forInstance: cbr;		instVarString: ci.	class := ClassBuilder new		addRecord: cbr;		addRecord: mbr;		reviseSystem.	^class</body></methods><methods><class-id>Kernel.NameSpace</class-id> <category>definition</category><body package="System-Name Spaces" selector="defineClass:superclass:indexedType:private:instanceVariableNames:classInstanceVariableNames:imports:category:attributes:author:createdAt:">defineClass: className superclass: superID indexedType: typeName private: isPrivate	instanceVariableNames: iVars classInstanceVariableNames: ciVars	imports: pools category: category attributes: attributes author: author createdAt: createdAt	| superclass approved class cbr mbr ci i |	superID == nil		ifTrue: [superclass := nil]		ifFalse: [(superID binding isForClass				or: [superID binding isForGeneral				and: [superID binding isConstant				and: [superID binding value isBehavior]]])			ifTrue: [superclass := superID value]			ifFalse: [self error: (#SuperclassMustBeAClass &lt;&lt; #dialogs &gt;&gt; 'The superclass of a class must also be a class')]].	Behavior checkLegalBehaviorType: typeName.	approved := SystemUtils			validateClassName: className			for: nil.	approved == nil ifTrue: [^nil].	cbr := (BehaviorBuilderRecord forName: approved in: self)			superclass: superclass;			instVarString: iVars;			category: category;			attributes: attributes;			behaviorType: typeName;			importString: pools;			private: isPrivate.	ci := Array new: (ciVars size) + 2.	ci at: 1 put: 'author'.	ci at: 2 put: 'createdAt'.	i := 2.	ciVars do: [:c | ci at: (i := i + 1) put: c].	(mbr := MetaclassBuilderRecord new)		forInstance: cbr;		instVarString: ci.	class := ClassBuilder new		addRecord: cbr;		addRecord: mbr;		reviseSystem.	^class</body></methods><methods><class-id>Kernel.NameSpace</class-id> <category>definition</category><body package="System-Name Spaces" selector="defineClass:superclass:indexedType:private:instanceVariableNames:classInstanceVariableNames:imports:category:attributes:author:createdAt:">defineClass: className superclass: superID indexedType: typeName private: isPrivate	instanceVariableNames: iVars classInstanceVariableNames: ciVars	imports: pools category: category attributes: attributes author: author createdAt: createdAt	| superclass approved class cbr mbr ci i |	superID == nil		ifTrue: [superclass := nil]		ifFalse: [(superID binding isForClass				or: [superID binding isForGeneral				and: [superID binding isConstant				and: [superID binding value isBehavior]]])			ifTrue: [superclass := superID value]			ifFalse: [self error: (#SuperclassMustBeAClass &lt;&lt; #dialogs &gt;&gt; 'The superclass of a class must also be a class')]].	Behavior checkLegalBehaviorType: typeName.	approved := SystemUtils			validateClassName: className			for: nil.	approved == nil ifTrue: [^nil].	cbr := (BehaviorBuilderRecord forName: approved in: self)			superclass: superclass;			instVarString: iVars;			category: category;			attributes: attributes;			behaviorType: typeName;			importString: pools;			private: isPrivate.	ci := Array new: (ciVars size) + 2.	ci at: 1 put: #author.	ci at: 2 put: #createdAt.	i := 2.	ciVars do: [:c | ci at: (i := i + 1) put: c].	(mbr := MetaclassBuilderRecord new)		forInstance: cbr;		instVarString: ci.	class := ClassBuilder new		addRecord: cbr;		addRecord: mbr;		reviseSystem.	^class</body></methods><methods><class-id>Kernel.NameSpace</class-id> <category>definition</category><body package="System-Name Spaces" selector="defineClass:superclass:indexedType:private:instanceVariableNames:classInstanceVariableNames:imports:category:attributes:author:createdAt:">defineClass: className superclass: superID indexedType: typeName private: isPrivate	instanceVariableNames: iVars classInstanceVariableNames: ciVars	imports: pools category: category attributes: attributes author: author createdAt: createdAt	| superclass approved class cbr mbr ci i |	superID == nil		ifTrue: [superclass := nil]		ifFalse: [(superID binding isForClass				or: [superID binding isForGeneral				and: [superID binding isConstant				and: [superID binding value isBehavior]]])			ifTrue: [superclass := superID value]			ifFalse: [self error: (#SuperclassMustBeAClass &lt;&lt; #dialogs &gt;&gt; 'The superclass of a class must also be a class')]].	Behavior checkLegalBehaviorType: typeName.	approved := SystemUtils			validateClassName: className			for: nil.	approved == nil ifTrue: [^nil].	cbr := (BehaviorBuilderRecord forName: approved in: self)			superclass: superclass;			instVarString: iVars;			category: category;			attributes: attributes;			behaviorType: typeName;			importString: pools;			private: isPrivate.	ci := Array new: (ciVars size) + 2.	ci at: 1 put: 'author'.	ci at: 2 put: 'createdAt'.	i := 2.	ciVars do: [:c | ci at: (i := i + 1) put: c].	(mbr := MetaclassBuilderRecord new)		forInstance: cbr;		instVarString: ci.	class := ClassBuilder new		addRecord: cbr;		addRecord: mbr;		reviseSystem.	^class</body></methods><methods><class-id>Kernel.NameSpace</class-id> <category>definition</category><body package="System-Name Spaces" selector="defineClass:superclass:indexedType:private:instanceVariableNames:classInstanceVariableNames:imports:category:attributes:author:createdAt:">defineClass: className superclass: superID indexedType: typeName private: isPrivate	instanceVariableNames: iVars classInstanceVariableNames: ciVars	imports: pools category: category attributes: attributes author: author createdAt: createdAt	| superclass approved class cbr mbr ci i |	superID == nil		ifTrue: [superclass := nil]		ifFalse: [(superID binding isForClass				or: [superID binding isForGeneral				and: [superID binding isConstant				and: [superID binding value isBehavior]]])			ifTrue: [superclass := superID value]			ifFalse: [self error: (#SuperclassMustBeAClass &lt;&lt; #dialogs &gt;&gt; 'The superclass of a class must also be a class')]].	Behavior checkLegalBehaviorType: typeName.	approved := SystemUtils			validateClassName: className			for: nil.	approved == nil ifTrue: [^nil].	cbr := (BehaviorBuilderRecord forName: approved in: self)			superclass: superclass;			instVarString: iVars;			category: category;			attributes: attributes;			behaviorType: typeName;			importString: pools;			private: isPrivate.	ci := Array new: (ciVars size) + 2.	ci at: 1 put: 'author'.	ci at: 2 put: 'createdAt'.	i := 2.	ciVars do: [:c | ci at: (i := i + 1) put: c].	(mbr := MetaclassBuilderRecord new)		forInstance: cbr;		instVarString: ciVars.	class := ClassBuilder new		addRecord: cbr;		addRecord: mbr;		reviseSystem.	^class</body></methods><class><name>Test</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>toto </class-inst-vars><imports></imports><category></category><attributes><package>controller</package></attributes></class><do-it>clas := Smalltalk defineClass: #Test superclass: #{Core.Object} indexedType: #none private: false instanceVariableNames: '' classInstanceVariableNames: 'toto' imports: '' category: ''</do-it><class><name>Test</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>toto </class-inst-vars><imports></imports><category></category><attributes><package>controller</package></attributes></class><do-it>clas := Smalltalk defineClass: #Test superclass: #{Core.Object} indexedType: #none private: false instanceVariableNames: '' classInstanceVariableNames: 'toto' imports: '' category: ''</do-it><do-it>clas</do-it><methods><class-id>Kernel.NameSpace</class-id> <category>definition</category><body package="System-Name Spaces" selector="defineClass:superclass:indexedType:private:instanceVariableNames:classInstanceVariableNames:imports:category:attributes:author:createdAt:">defineClass: className superclass: superID indexedType: typeName private: isPrivate	instanceVariableNames: iVars classInstanceVariableNames: ciVars	imports: pools category: category attributes: attributes author: author createdAt: createdAt	| superclass approved class cbr mbr ci i |	superID == nil		ifTrue: [superclass := nil]		ifFalse: [(superID binding isForClass				or: [superID binding isForGeneral				and: [superID binding isConstant				and: [superID binding value isBehavior]]])			ifTrue: [superclass := superID value]			ifFalse: [self error: (#SuperclassMustBeAClass &lt;&lt; #dialogs &gt;&gt; 'The superclass of a class must also be a class')]].	Behavior checkLegalBehaviorType: typeName.	approved := SystemUtils			validateClassName: className			for: nil.	approved == nil ifTrue: [^nil].	cbr := (BehaviorBuilderRecord forName: approved in: self)			superclass: superclass;			instVarString: iVars;			category: category;			attributes: attributes;			behaviorType: typeName;			importString: pools;			private: isPrivate.	ci := Array new: (ciVars size) + 2.	ci at: 1 put: 'author'.	ci at: 2 put: 'createdAt'.	i := 2.	ciVars do: [:c | ci at: (i := i + 1) put: c].	(mbr := MetaclassBuilderRecord new)		forInstance: cbr;		instVarString: #(ciVars #author #createdAt).	class := ClassBuilder new		addRecord: cbr;		addRecord: mbr;		reviseSystem.	^class</body></methods><class><name>Test</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>ciVars author createdAt </class-inst-vars><imports></imports><category></category><attributes><package>controller</package></attributes></class><do-it>clas := Smalltalk defineClass: #Test superclass: #{Core.Object} indexedType: #none private: false instanceVariableNames: '' classInstanceVariableNames: 'toto' imports: '' category: ''</do-it><class><name>Test</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>ciVars author createdAt </class-inst-vars><imports></imports><category></category><attributes><package>controller</package></attributes></class><do-it>clas := Smalltalk defineClass: #Test superclass: #{Core.Object} indexedType: #none private: false instanceVariableNames: '' classInstanceVariableNames: 'toto' imports: '' category: ''</do-it><methods><class-id>Kernel.NameSpace</class-id> <category>definition</category><body package="System-Name Spaces" selector="defineClass:superclass:indexedType:private:instanceVariableNames:classInstanceVariableNames:imports:category:attributes:author:createdAt:">defineClass: className superclass: superID indexedType: typeName private: isPrivate	instanceVariableNames: iVars classInstanceVariableNames: ciVars	imports: pools category: category attributes: attributes author: author createdAt: createdAt	| superclass approved class cbr mbr ci i |	superID == nil		ifTrue: [superclass := nil]		ifFalse: [(superID binding isForClass				or: [superID binding isForGeneral				and: [superID binding isConstant				and: [superID binding value isBehavior]]])			ifTrue: [superclass := superID value]			ifFalse: [self error: (#SuperclassMustBeAClass &lt;&lt; #dialogs &gt;&gt; 'The superclass of a class must also be a class')]].	Behavior checkLegalBehaviorType: typeName.	approved := SystemUtils			validateClassName: className			for: nil.	approved == nil ifTrue: [^nil].	cbr := (BehaviorBuilderRecord forName: approved in: self)			superclass: superclass;			instVarString: iVars;			category: category;			attributes: attributes;			behaviorType: typeName;			importString: pools;			private: isPrivate.	ci := Array new: (ciVars size) + 2.	ci at: 1 put: 'author'.	ci at: 2 put: 'createdAt'.	i := 2.	ciVars do: [:c | ci at: (i := i + 1) put: c].	(mbr := MetaclassBuilderRecord new)		forInstance: cbr;		instVarString: #(ciVars author createdAt).	class := ClassBuilder new		addRecord: cbr;		addRecord: mbr;		reviseSystem.	^class</body></methods><class><name>Test</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>ciVars author createdAt </class-inst-vars><imports></imports><category></category><attributes><package>controller</package></attributes></class><do-it>clas := Smalltalk defineClass: #Test superclass: #{Core.Object} indexedType: #none private: false instanceVariableNames: '' classInstanceVariableNames: 'toto' imports: '' category: ''</do-it><class><name>Test</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>ciVars author createdAt </class-inst-vars><imports></imports><category></category><attributes><package>controller</package></attributes></class><do-it>clas := Smalltalk defineClass: #Test superclass: #{Core.Object} indexedType: #none private: false instanceVariableNames: '' classInstanceVariableNames: 'toto' imports: '' category: ''</do-it><class><name>Test</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>ciVars author createdAt </class-inst-vars><imports></imports><category></category><attributes><package>controller</package></attributes></class><do-it>clas := Smalltalk defineClass: #Test superclass: #{Core.Object} indexedType: #none private: false instanceVariableNames: '' classInstanceVariableNames: 'toto' imports: '' category: ''</do-it><methods><class-id>Kernel.NameSpace</class-id> <category>definition</category><body package="System-Name Spaces" selector="defineClass:superclass:indexedType:private:instanceVariableNames:classInstanceVariableNames:imports:category:attributes:author:createdAt:">defineClass: className superclass: superID indexedType: typeName private: isPrivate	instanceVariableNames: iVars classInstanceVariableNames: ciVars	imports: pools category: category attributes: attributes author: author createdAt: createdAt	| superclass approved class cbr mbr |	superID == nil		ifTrue: [superclass := nil]		ifFalse: [(superID binding isForClass				or: [superID binding isForGeneral				and: [superID binding isConstant				and: [superID binding value isBehavior]]])			ifTrue: [superclass := superID value]			ifFalse: [self error: (#SuperclassMustBeAClass &lt;&lt; #dialogs &gt;&gt; 'The superclass of a class must also be a class')]].	Behavior checkLegalBehaviorType: typeName.	approved := SystemUtils			validateClassName: className			for: nil.	approved == nil ifTrue: [^nil].	cbr := (BehaviorBuilderRecord forName: approved in: self)			superclass: superclass;			instVarString: iVars;			category: category;			attributes: attributes;			behaviorType: typeName;			importString: pools;			private: isPrivate.	(mbr := MetaclassBuilderRecord new)		forInstance: cbr;		instVarString: #(ciVars author createdAt).	class := ClassBuilder new		addRecord: cbr;		addRecord: mbr;		reviseSystem.	^class</body></methods><methods><class-id>Kernel.NameSpace</class-id> <category>definition</category><body package="System-Name Spaces" selector="defineClass:superclass:indexedType:private:instanceVariableNames:classInstanceVariableNames:imports:category:attributes:author:createdAt:">defineClass: className superclass: superID indexedType: typeName private: isPrivate	instanceVariableNames: iVars classInstanceVariableNames: ciVars	imports: pools category: category attributes: attributes author: author createdAt: createdAt	| superclass approved class cbr mbr |	superID == nil		ifTrue: [superclass := nil]		ifFalse: [(superID binding isForClass				or: [superID binding isForGeneral				and: [superID binding isConstant				and: [superID binding value isBehavior]]])			ifTrue: [superclass := superID value]			ifFalse: [self error: (#SuperclassMustBeAClass &lt;&lt; #dialogs &gt;&gt; 'The superclass of a class must also be a class')]].	Behavior checkLegalBehaviorType: typeName.	approved := SystemUtils			validateClassName: className			for: nil.	approved == nil ifTrue: [^nil].	cbr := (BehaviorBuilderRecord forName: approved in: self)			superclass: superclass;			instVarString: iVars;			category: category;			attributes: attributes;			behaviorType: typeName;			importString: pools;			private: isPrivate.	(mbr := MetaclassBuilderRecord new)		forInstance: cbr;		instVarString: ciVars, #(author createdAt).	class := ClassBuilder new		addRecord: cbr;		addRecord: mbr;		reviseSystem.	^class</body></methods><do-it>anArray := #(1 2 3 4).anotherArray := #(5 6 7).</do-it><do-it>anArray, anotherArray</do-it><do-it>a := 2</do-it><methods><class-id>Kernel.NameSpace</class-id> <category>definition</category><body package="System-Name Spaces" selector="defineClass:superclass:indexedType:private:instanceVariableNames:classInstanceVariableNames:imports:category:attributes:author:createdAt:">defineClass: className superclass: superID indexedType: typeName private: isPrivate	instanceVariableNames: iVars classInstanceVariableNames: ciVars	imports: pools category: category attributes: attributes author: author createdAt: createdAt	| superclass approved class cbr mbr |	superID == nil		ifTrue: [superclass := nil]		ifFalse: [(superID binding isForClass				or: [superID binding isForGeneral				and: [superID binding isConstant				and: [superID binding value isBehavior]]])			ifTrue: [superclass := superID value]			ifFalse: [self error: (#SuperclassMustBeAClass &lt;&lt; #dialogs &gt;&gt; 'The superclass of a class must also be a class')]].	Behavior checkLegalBehaviorType: typeName.	approved := SystemUtils			validateClassName: className			for: nil.	approved == nil ifTrue: [^nil].	cbr := (BehaviorBuilderRecord forName: approved in: self)			superclass: superclass;			instVarString: iVars;			category: category;			attributes: attributes;			behaviorType: typeName;			importString: pools;			private: isPrivate.		(mbr := MetaclassBuilderRecord new)		forInstance: cbr;		instVarString: ciVars, 'author createdAt'.	class := ClassBuilder new		addRecord: cbr;		addRecord: mbr;		reviseSystem.	^class</body></methods><methods><class-id>Kernel.NameSpace</class-id> <category>definition</category><body package="System-Name Spaces" selector="defineClass:superclass:indexedType:private:instanceVariableNames:classInstanceVariableNames:imports:category:attributes:author:createdAt:">defineClass: className superclass: superID indexedType: typeName private: isPrivate	instanceVariableNames: iVars classInstanceVariableNames: ciVars	imports: pools category: category attributes: attributes author: author createdAt: createdAt	| superclass approved class cbr mbr |	superID == nil		ifTrue: [superclass := nil]		ifFalse: [(superID binding isForClass				or: [superID binding isForGeneral				and: [superID binding isConstant				and: [superID binding value isBehavior]]])			ifTrue: [superclass := superID value]			ifFalse: [self error: (#SuperclassMustBeAClass &lt;&lt; #dialogs &gt;&gt; 'The superclass of a class must also be a class')]].	Behavior checkLegalBehaviorType: typeName.	approved := SystemUtils			validateClassName: className			for: nil.	approved == nil ifTrue: [^nil].	cbr := (BehaviorBuilderRecord forName: approved in: self)			superclass: superclass;			instVarString: iVars;			category: category;			attributes: attributes;			behaviorType: typeName;			importString: pools;			private: isPrivate.		(mbr := MetaclassBuilderRecord new)		forInstance: cbr;		instVarString: ciVars, ' author createdAt'.	class := ClassBuilder new		addRecord: cbr;		addRecord: mbr;		reviseSystem.	^class</body></methods><class><name>Test</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>toto author createdAt </class-inst-vars><imports></imports><category></category><attributes><package>controller</package></attributes></class><do-it>clas := Smalltalk defineClass: #Test superclass: #{Core.Object} indexedType: #none private: false instanceVariableNames: '' classInstanceVariableNames: 'toto' imports: '' category: ''</do-it><class><name>Test</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>toto author createdAt </class-inst-vars><imports></imports><category></category><attributes><package>controller</package></attributes></class><do-it>clasTest := Smalltalk defineClass: #Test superclass: #{Core.Object} indexedType: #none private: false instanceVariableNames: '' classInstanceVariableNames: 'toto' imports: '' category: ''</do-it><do-it>clasTest new.</do-it><do-it>clasTest new.</do-it><do-it>clasTest class</do-it><do-it>Test removeFromSystem</do-it><class><name>Test</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>author createdAt </class-inst-vars><imports></imports><category></category><attributes><package>controller</package></attributes></class><methods><class-id>Test</class-id> <category>initialize-release</category><body package="controller" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>Test class</class-id> <category>instance creation</category><body package="controller" selector="new">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><do-it>Test removeFromSystem</do-it><class><name>Tesst</name><environment>Smalltalk</environment><super>ManageUserController</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>author createdAt </class-inst-vars><imports></imports><category></category><attributes><package>controller</package></attributes></class><methods><class-id>Tesst</class-id> <category>initialize-release</category><body package="controller" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>Tesst</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>Tesst</staticKey> <definitionChange>added</definitionChange></component_static_change><do-it>Tesst removeFromSystem</do-it><methods><class-id>Kernel.NameSpace</class-id> <category>definition</category><body package="System-Name Spaces" selector="defineClass:superclass:indexedType:private:instanceVariableNames:classInstanceVariableNames:imports:category:attributes:author:createdAt:">defineClass: className superclass: superID indexedType: typeName private: isPrivate	instanceVariableNames: iVars classInstanceVariableNames: ciVars	imports: pools category: category attributes: attributes author: author createdAt: createdAt	| superclass approved class cbr mbr |	superID == nil		ifTrue: [superclass := nil]		ifFalse: [(superID binding isForClass				or: [superID binding isForGeneral				and: [superID binding isConstant				and: [superID binding value isBehavior]]])			ifTrue: [superclass := superID value]			ifFalse: [self error: (#SuperclassMustBeAClass &lt;&lt; #dialogs &gt;&gt; 'The superclass of a class must also be a class')]].	Behavior checkLegalBehaviorType: typeName.	approved := SystemUtils			validateClassName: className			for: nil.	approved == nil ifTrue: [^nil].	cbr := (BehaviorBuilderRecord forName: approved in: self)			superclass: superclass;			instVarString: iVars;			category: category;			attributes: attributes;			behaviorType: typeName;			importString: pools;			private: isPrivate.		(mbr := MetaclassBuilderRecord new)		forInstance: cbr;		instVarString: ciVars", ' author createdAt'".	class := ClassBuilder new		addRecord: cbr;		addRecord: mbr;		reviseSystem.	^class</body></methods><methods><class-id>Core.Class class</class-id> <category>accessing</category><body package="Kernel-Classes" selector="author">author	^author</body></methods><methods><class-id>Core.Class class</class-id> <category>accessing</category><body package="Kernel-Classes" selector="author:">author: anObject	author := anObject</body></methods><methods><class-id>Core.Class class</class-id> <category>accessing</category><body package="Kernel-Classes" selector="createdAt">createdAt	^createdAt</body></methods><methods><class-id>Core.Class class</class-id> <category>accessing</category><body package="Kernel-Classes" selector="createdAt:">createdAt: anObject	createdAt := anObject</body></methods><class><name>Test</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>controller</package></attributes></class><methods><class-id>Test</class-id> <category>initialize-release</category><body package="controller" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>Test class</class-id> <category>instance creation</category><body package="controller" selector="new">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><comment><class-id>Test</class-id><body>Test has not been commented.  The comment should state the purpose of the class and also explain any unobvious aspects of the implementation.</body></comment><do-it>Test class</do-it><do-it>Test</do-it><do-it>Test removeFromSystem</do-it><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>createdAt</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>createdAt</staticKey> <definitionChange>added</definitionChange></component_static_change><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>author</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>author</staticKey> <definitionChange>added</definitionChange></component_static_change><class><name>Class</name><environment>Core</environment><super>Core.ClassDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name classPool environment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><remove-selector><class-id>Core.Class class</class-id> <selector>author</selector></remove-selector><remove-selector><class-id>Core.Class class</class-id> <selector>createdAt:</selector></remove-selector><remove-selector><class-id>Core.Class class</class-id> <selector>createdAt</selector></remove-selector><remove-selector><class-id>Core.Class class</class-id> <selector>author:</selector></remove-selector><do-it>Class class organization removeCategory: #accessing</do-it><methods><class-id>Kernel.NameSpace</class-id> <category>definition</category><body package="System-Name Spaces" selector="defineClass:superclass:indexedType:private:instanceVariableNames:classInstanceVariableNames:imports:category:attributes:author:createdAt:">defineClass: className superclass: superID indexedType: typeName private: isPrivate	instanceVariableNames: iVars classInstanceVariableNames: ciVars	imports: pools category: category attributes: attributes author: author createdAt: createdAt	| superclass approved class cbr mbr |	superID == nil		ifTrue: [superclass := nil]		ifFalse: [(superID binding isForClass				or: [superID binding isForGeneral				and: [superID binding isConstant				and: [superID binding value isBehavior]]])			ifTrue: [superclass := superID value]			ifFalse: [self error: (#SuperclassMustBeAClass &lt;&lt; #dialogs &gt;&gt; 'The superclass of a class must also be a class')]].	Behavior checkLegalBehaviorType: typeName.	approved := SystemUtils			validateClassName: className			for: nil.	approved == nil ifTrue: [^nil].	cbr := (BehaviorBuilderRecord forName: approved in: self)			superclass: superclass;			instVarString: iVars;			category: category;			attributes: attributes;			behaviorType: typeName;			importString: pools;			private: isPrivate.		(mbr := MetaclassBuilderRecord new)		forInstance: cbr;		instVarString: ciVars, ' author createdAt'.	class := ClassBuilder new		addRecord: cbr;		addRecord: mbr;		reviseSystem.	class author: author.	class createdAt: createdAt.	^class</body></methods><class><name>Test</name><environment>Smalltalk</environment><super>ManageUserController</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>author createdAt </class-inst-vars><imports></imports><category></category><attributes><package>controller</package></attributes></class><do-it>Test removeFromSystem</do-it><methods><class-id>Kernel.NameSpace</class-id> <category>definition</category><body package="System-Name Spaces" selector="defineClass:superclass:indexedType:private:instanceVariableNames:classInstanceVariableNames:imports:category:attributes:author:createdAt:">defineClass: className superclass: superID indexedType: typeName private: isPrivate	instanceVariableNames: iVars classInstanceVariableNames: ciVars	imports: pools category: category attributes: attributes author: author createdAt: createdAt	| superclass approved class cbr mbr |	superID == nil		ifTrue: [superclass := nil]		ifFalse: [(superID binding isForClass				or: [superID binding isForGeneral				and: [superID binding isConstant				and: [superID binding value isBehavior]]])			ifTrue: [superclass := superID value]			ifFalse: [self error: (#SuperclassMustBeAClass &lt;&lt; #dialogs &gt;&gt; 'The superclass of a class must also be a class')]].	Behavior checkLegalBehaviorType: typeName.	approved := SystemUtils			validateClassName: className			for: nil.	approved == nil ifTrue: [^nil].	cbr := (BehaviorBuilderRecord forName: approved in: self)			superclass: superclass;			instVarString: iVars;			category: category;			attributes: attributes;			behaviorType: typeName;			importString: pools;			private: isPrivate.	(mbr := MetaclassBuilderRecord new)		forInstance: cbr;		instVarString: ciVars.	class := ClassBuilder new		addRecord: cbr;		addRecord: mbr;		reviseSystem.	class author: author.	class createdAt: createdAt.	^class</body></methods><methods><class-id>Kernel.NameSpace</class-id> <category>definition</category><body package="System-Name Spaces" selector="defineClass:superclass:indexedType:private:instanceVariableNames:classInstanceVariableNames:imports:category:attributes:">defineClass: className superclass: superID indexedType: typeName private: isPrivate	instanceVariableNames: iVars classInstanceVariableNames: ciVars	imports: pools category: category attributes: attributes	| superclass approved class cbr mbr |	superID == nil		ifTrue: [superclass := nil]		ifFalse: [(superID binding isForClass				or: [superID binding isForGeneral				and: [superID binding isConstant				and: [superID binding value isBehavior]]])			ifTrue: [superclass := superID value]			ifFalse: [self error: (#SuperclassMustBeAClass &lt;&lt; #dialogs &gt;&gt; 'The superclass of a class must also be a class')]].	Behavior checkLegalBehaviorType: typeName.	approved := SystemUtils			validateClassName: className			for: nil.	approved == nil ifTrue: [^nil].	cbr := (BehaviorBuilderRecord forName: approved in: self)			superclass: superclass;			instVarString: iVars;			category: category;			attributes: attributes;			behaviorType: typeName;			importString: pools;			private: isPrivate.	(mbr := MetaclassBuilderRecord new)		forInstance: cbr;		instVarString: ciVars.	class := ClassBuilder new		addRecord: cbr;		addRecord: mbr;		reviseSystem.		^class</body></methods><methods><class-id>Kernel.NameSpace</class-id> <category>definition</category><body package="System-Name Spaces" selector="defineClass:superclass:indexedType:private:instanceVariableNames:classInstanceVariableNames:imports:category:">defineClass: className superclass: superID indexedType: typeName private: isPrivate	instanceVariableNames: iVars classInstanceVariableNames: ciVars	imports: pools category: category	^self defineClass: className		superclass: superID		indexedType: typeName		private: isPrivate		instanceVariableNames: iVars		classInstanceVariableNames: ciVars		imports: pools		category: category		attributes: #( )</body></methods><remove-selector><class-id>Kernel.NameSpace</class-id> <selector>defineClass:superclass:indexedType:private:instanceVariableNames:classInstanceVariableNames:imports:category:attributes:author:createdAt:</selector></remove-selector><class><name>Class</name><environment>Core</environment><super>Core.ClassDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name classPool environment </inst-vars><class-inst-vars>author createdAt </class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><comment><class-id>Core.Class</class-id><body>Instances of class Class describe the representation and behavior of objects.  Class adds more comprehensive programming support facilities to the basic attributes of Behavior and the descriptive facilities of ClassDescription.  An example is accessing shared (pool) variables.Instance Variables:	name		&lt;Symbol&gt; name of class for printing and global reference	classPool	&lt;PoolDictionary | nil&gt; of variables common to all instances	environment	&lt;Namespace | nil&gt; the name space corresponding to this classClass Instance Variables:	author		&lt;String&gt; name of the author of the class	createdAt	&lt;Date&gt; date of creation of the class	</body></comment><class><name>Class</name><environment>Core</environment><super>Core.ClassDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name classPool environment author createdAt </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><comment><class-id>Core.Class</class-id><body>Instances of class Class describe the representation and behavior of objects.  Class adds more comprehensive programming support facilities to the basic attributes of Behavior and the descriptive facilities of ClassDescription.  An example is accessing shared (pool) variables.Instance Variables:	name		&lt;Symbol&gt; name of class for printing and global reference	classPool	&lt;PoolDictionary | nil&gt; of variables common to all instances	environment	&lt;Namespace | nil&gt; the name space corresponding to this class	author		&lt;String&gt; name of the author of the class	createdAt	&lt;Date&gt; date of creation of the class	</body></comment><methods><class-id>Core.Class</class-id> <category>accessing</category><body package="Kernel-Classes" selector="author">author	^author</body></methods><methods><class-id>Core.Class</class-id> <category>accessing</category><body package="Kernel-Classes" selector="author:">author: anObject	author := anObject</body></methods><methods><class-id>Core.Class</class-id> <category>accessing</category><body package="Kernel-Classes" selector="createdAt">createdAt	^createdAt</body></methods><methods><class-id>Core.Class</class-id> <category>accessing</category><body package="Kernel-Classes" selector="createdAt:">createdAt: anObject	createdAt := anObject</body></methods><methods><class-id>Kernel.NameSpace</class-id> <category>definition</category><body package="System-Name Spaces" selector="defineClass:superclass:indexedType:private:instanceVariableNames:classInstanceVariableNames:imports:category:attributes:">defineClass: className superclass: superID indexedType: typeName private: isPrivate	instanceVariableNames: iVars classInstanceVariableNames: ciVars	imports: pools category: category attributes: attributes	| superclass approved class cbr mbr |	superID == nil		ifTrue: [superclass := nil]		ifFalse: [(superID binding isForClass				or: [superID binding isForGeneral				and: [superID binding isConstant				and: [superID binding value isBehavior]]])			ifTrue: [superclass := superID value]			ifFalse: [self error: (#SuperclassMustBeAClass &lt;&lt; #dialogs &gt;&gt; 'The superclass of a class must also be a class')]].	Behavior checkLegalBehaviorType: typeName.	approved := SystemUtils			validateClassName: className			for: nil.	approved == nil ifTrue: [^nil].	cbr := (BehaviorBuilderRecord forName: approved in: self)			superclass: superclass;			instVarString: iVars;			category: category;			attributes: attributes;			behaviorType: typeName;			importString: pools;			private: isPrivate.	(mbr := MetaclassBuilderRecord new)		forInstance: cbr;		instVarString: ciVars.	class := ClassBuilder new		addRecord: cbr;		addRecord: mbr;		reviseSystem.	class author: UserArray getInstance currentUser.	class createdAt: Date today.	^class</body></methods><class><name>Test</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>controller</package></attributes></class><methods><class-id>Test</class-id> <category>initialize-release</category><body package="controller" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>Test class</class-id> <category>instance creation</category><body package="controller" selector="new">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><do-it>Test</do-it><do-it>Test removeFromSystem</do-it><class><name>Test</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>controller</package></attributes></class><methods><class-id>Test</class-id> <category>initialize-release</category><body package="controller" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>Test class</class-id> <category>instance creation</category><body package="controller" selector="new">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><do-it>Test</do-it><do-it>Test removeFromSystem</do-it><do-it>#{Kernel.Undeclared.author} removeFromSystem</do-it><do-it>#{Kernel.Undeclared.User} removeFromSystem</do-it><do-it>#{Kernel.Undeclared.Test} removeFromSystem</do-it><do-it>#{Kernel.Undeclared.Tesst} removeFromSystem</do-it><do-it>#{Kernel.Undeclared.ManageUserController} removeFromSystem</do-it><do-it>#{Kernel.Undeclared.createdAt} removeFromSystem</do-it><do-it>#{Kernel.Undeclared.UserArray} removeFromSystem</do-it><do-it>Undeclared organization removeCategory: #'As yet unclassified'</do-it><comment><class-id>Core.Class</class-id><body>Instances of class Class describe the representation and behavior of objects.  Class adds more comprehensive programming support facilities to the basic attributes of Behavior and the descriptive facilities of ClassDescription.  An example is accessing shared (pool) variables.Instance Variables:	name		&lt;Symbol&gt; name of class for printing and global reference	classPool	&lt;PoolDictionary | nil&gt; of variables common to all instances	environment	&lt;Namespace | nil&gt; the name space corresponding to this class</body></comment><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>user</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>user</staticKey> <definitionChange>added</definitionChange></component_static_change><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>date</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>date</staticKey> <definitionChange>added</definitionChange></component_static_change><class><name>Class</name><environment>Core</environment><super>Core.ClassDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name classPool environment author createdAt </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><comment><class-id>Core.Class</class-id><body>Instances of class Class describe the representation and behavior of objects.  Class adds more comprehensive programming support facilities to the basic attributes of Behavior and the descriptive facilities of ClassDescription.  An example is accessing shared (pool) variables.Instance Variables:	name		&lt;Symbol&gt; name of class for printing and global reference	classPool	&lt;PoolDictionary | nil&gt; of variables common to all instances	environment	&lt;Namespace | nil&gt; the name space corresponding to this class	author		&lt;String&gt; author of the class	createdAt	&lt;Date&gt; creation date of the class</body></comment><methods><class-id>Core.Class</class-id> <category>accessing</category><body package="Kernel-Classes" selector="author">author	^author</body></methods><methods><class-id>Core.Class</class-id> <category>accessing</category><body package="Kernel-Classes" selector="author:">author: anObject	author := anObject</body></methods><methods><class-id>Core.Class</class-id> <category>accessing</category><body package="Kernel-Classes" selector="createdAt">createdAt	^createdAt</body></methods><methods><class-id>Core.Class</class-id> <category>accessing</category><body package="Kernel-Classes" selector="createdAt:">createdAt: anObject	createdAt := anObject</body></methods><methods><class-id>Kernel.NameSpace</class-id> <category>definition</category><body package="System-Name Spaces" selector="defineClass:superclass:indexedType:private:instanceVariableNames:classInstanceVariableNames:imports:category:attributes:">defineClass: className superclass: superID indexedType: typeName private: isPrivate	instanceVariableNames: iVars classInstanceVariableNames: ciVars	imports: pools category: category attributes: attributes	| superclass approved class cbr mbr |	superID == nil		ifTrue: [superclass := nil]		ifFalse: [(superID binding isForClass				or: [superID binding isForGeneral				and: [superID binding isConstant				and: [superID binding value isBehavior]]])			ifTrue: [superclass := superID value]			ifFalse: [self error: (#SuperclassMustBeAClass &lt;&lt; #dialogs &gt;&gt; 'The superclass of a class must also be a class')]].	Behavior checkLegalBehaviorType: typeName.	approved := SystemUtils			validateClassName: className			for: nil.	approved == nil ifTrue: [^nil].	cbr := (BehaviorBuilderRecord forName: approved in: self)			superclass: superclass;			instVarString: iVars;			category: category;			attributes: attributes;			behaviorType: typeName;			importString: pools;			private: isPrivate.	(mbr := MetaclassBuilderRecord new)		forInstance: cbr;		instVarString: ciVars.	class := ClassBuilder new		addRecord: cbr;		addRecord: mbr;		reviseSystem.	class author: UserArray getInstance currentUser.	class createdAt: Date dateAndTimeNow.	^class</body></methods><class><name>Test</name><environment>Smalltalk</environment><super>UserArray</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>model</package></attributes></class><methods><class-id>Test</class-id> <category>initialize-release</category><body package="model" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>Test</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>Test</staticKey> <definitionChange>added</definitionChange></component_static_change><do-it>Test removeFromSystem</do-it><class><name>Test</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>controller</package></attributes></class><methods><class-id>Test</class-id> <category>initialize-release</category><body package="controller" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>Test class</class-id> <category>instance creation</category><body package="controller" selector="new">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><do-it>Test</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/kevin/VisualWorks Projects/ProjetInfo606/ProjetInfo606.im' 'February 9, 2021' '10:21:42 PM')""An image file /home/kevin/VisualWorks Projects/ProjetInfo606/ProjetInfo606.im was created at 22:21:42 on 9 fvrier 2021."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/kevin/VisualWorks Projects/ProjetInfo606/ProjetInfo606.im' 'February 9, 2021' '10:23:38 PM')""An image file /home/kevin/VisualWorks Projects/ProjetInfo606/ProjetInfo606.im was created at 22:23:38 on 9 fvrier 2021."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/kevin/VisualWorks Projects/ProjetInfo606/ProjetInfo606.im' 'February 9, 2021' '10:23:48 PM')""An image file /home/kevin/VisualWorks Projects/ProjetInfo606/ProjetInfo606.im was created at 22:23:48 on 9 fvrier 2021."</do-it><do-it>Test removeFromSystem</do-it><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>date</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>date</staticKey> <definitionChange>added</definitionChange></component_static_change><do-it>#{Kernel.Undeclared.date} removeFromSystem</do-it><do-it>#{Kernel.Undeclared.UserArray} removeFromSystem</do-it><do-it>#{Kernel.Undeclared.User} removeFromSystem</do-it><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>user</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>user</staticKey> <definitionChange>added</definitionChange></component_static_change><do-it>#{Kernel.Undeclared.user} removeFromSystem</do-it><do-it>#{Kernel.Undeclared.Test} removeFromSystem</do-it><do-it>#{Kernel.Undeclared.ManageUserController} removeFromSystem</do-it><remove-selector><class-id>Core.Class class</class-id> <selector>date</selector></remove-selector><remove-selector><class-id>Core.Class class</class-id> <selector>date:</selector></remove-selector><remove-selector><class-id>Core.Class class</class-id> <selector>user</selector></remove-selector><remove-selector><class-id>Core.Class class</class-id> <selector>user:</selector></remove-selector><do-it>Class class organization removeCategory: #accessing</do-it><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>user</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>user</staticKey> <definitionChange>added</definitionChange></component_static_change><do-it>#{Kernel.Undeclared.user} removeFromSystem</do-it><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>date</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>date</staticKey> <definitionChange>added</definitionChange></component_static_change><do-it>#{Kernel.Undeclared.date} removeFromSystem</do-it><do-it>#{Kernel.Undeclared.date} removeFromSystem</do-it><do-it>#{Kernel.Undeclared.user} removeFromSystem</do-it><do-it>Undeclared organization removeCategory: #'As yet unclassified'</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/kevin/VisualWorks Projects/ProjetInfo606/ProjetInfo606.im' 'February 9, 2021' '10:26:04 PM')""An image file /home/kevin/VisualWorks Projects/ProjetInfo606/ProjetInfo606.im was created at 22:26:04 on 9 fvrier 2021."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/kevin/VisualWorks Projects/ProjetInfo606/ProjetInfo606.im' 'February 9, 2021' '10:26:18 PM')""An image file /home/kevin/VisualWorks Projects/ProjetInfo606/ProjetInfo606.im was created at 22:26:18 on 9 fvrier 2021."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/kevin/VisualWorks Projects/ProjetInfo606/ProjetInfo606.im' 'February 9, 2021' '10:26:35 PM')""An image file /home/kevin/VisualWorks Projects/ProjetInfo606/ProjetInfo606.im was created at 22:26:35 on 9 fvrier 2021."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/kevin/VisualWorks Projects/ProjetInfo606/ProjetInfo606.im' 'February 9, 2021' '10:26:38 PM')""An image file /home/kevin/VisualWorks Projects/ProjetInfo606/ProjetInfo606.im was created at 22:26:38 on 9 fvrier 2021."</do-it><do-it>'----SNAPSHOT----'</do-it><do-it>"#('/home/kevin/VisualWorks Projects/ProjetInfo606/ProjetInfo606.im' 'February 9, 2021' '10:36:24 PM')""An image file /home/kevin/VisualWorks Projects/ProjetInfo606/ProjetInfo606.im was created at 22:36:24 on 9 fvrier 2021."</do-it><methods><class-id>UserArray</class-id> <category>removing</category><body package="model" selector="remove:">remove: userName	| i |	i := self indexOf: userName.	(i = 0) ifFalse: [		self at: i put: ''.	].</body></methods><methods><class-id>UserArray</class-id> <category>adding</category><body package="model" selector="add:">add: anObject	| i b |	i := self indexOf: ''.	b := self indexOf: anObject.	((i = 0) &amp; (b ~= 0)) ifFalse: [		self at: i put: anObject.	].</body></methods><do-it>UserArray</do-it><do-it>UserArray</do-it><methods><class-id>UserArray</class-id> <category>adding</category><body package="model" selector="add:">add: anObject	| i b |	i := self indexOf: nil.	b := self indexOf: anObject.	((i = 0) &amp; (b ~= 0)) ifFalse: [		self at: i put: anObject.	].</body></methods><methods><class-id>UserArray</class-id> <category>removing</category><body package="model" selector="remove:">remove: userName	| i |	i := self indexOf: userName.	(i = 0) ifFalse: [		self at: i put: nil.	].</body></methods><class><name>UserAndClassListInterface</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>view</package></attributes></class><methods><class-id>UserAndClassListInterface class</class-id> <category>interface specs</category><body package="view" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'User and class list' 			#bounds: #(#{Graphics.Rectangle} 858 483 1787 999 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 210 0 514 0 ) 					#name: #UserList 					#model: #userList 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 213 0 -1 0 460 0 515 0 ) 					#name: #ClassList 					#model: #classList 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.DocumentViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 461 0 -1 0 920 0 513 0 ) 					#name: #ClassDetails 					#isOpaque: true 					#model: #classDetails 					#isWrapped: true 					#isReadOnly: true 					#showHiddenCharacters: false 					#showLineStriping: false 					#autoAccept: true 					#continuousAccept: false 					#showInputCursor: false 					#showSelection: true ) ) ) )</body></methods><methods><class-id>UserAndClassListInterface class</class-id> <category>interface specs</category><body package="view" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'User and class list' 			#bounds: #(#{Graphics.Rectangle} 858 483 1787 999 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 210 0 514 0 ) 					#name: #UserList 					#model: #userList 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 213 0 -1 0 460 0 515 0 ) 					#name: #ClassList 					#model: #classList 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.DocumentViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 461 0 -1 0 920 0 513 0 ) 					#name: #ClassDetails 					#isOpaque: true 					#model: #classDetails 					#isWrapped: true 					#isReadOnly: true 					#showHiddenCharacters: false 					#showLineStriping: false 					#autoAccept: true 					#continuousAccept: false 					#showInputCursor: false 					#showSelection: true ) ) ) )</body></methods><class><name>UserAndClassListInterface</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>classDetails </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>view</package></attributes></class><do-it>Smalltalk defineClass: #UserAndClassListInterface	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: ' classDetails '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>UserAndClassListInterface</class-id> <category>aspects</category><body package="view" selector="classDetails">classDetails	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^classDetails isNil		ifTrue:			[classDetails := ((Text2.Document new: 0)) asValue]		ifFalse:			[classDetails]</body></methods><class><name>UserAndClassListInterface</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>classDetails userList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>view</package></attributes></class><do-it>Smalltalk defineClass: #UserAndClassListInterface	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'classDetails  userList '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>UserAndClassListInterface</class-id> <category>aspects</category><body package="view" selector="userList">userList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^userList isNil		ifTrue:			[userList := SelectionInList new]		ifFalse:			[userList]</body></methods><class><name>UserAndClassListInterface</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>classDetails userList classList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>view</package></attributes></class><do-it>Smalltalk defineClass: #UserAndClassListInterface	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'classDetails userList  classList '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>UserAndClassListInterface</class-id> <category>aspects</category><body package="view" selector="classList">classList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^classList isNil		ifTrue:			[classList := SelectionInList new]		ifFalse:			[classList]</body></methods><class><name>UserAndClassListInterface</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>classDetails userList classList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>view</package></attributes></class><do-it>Smalltalk defineClass: #UserAndClassListInterface	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'classDetails userList classList  '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>UserAndClassListInterface</class-id> <category>aspects</category><body package="view" selector="classDetails">classDetails	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^classDetails isNil		ifTrue:			[classDetails := ((Text2.Document new: 0)) asValue]		ifFalse:			[classDetails]</body></methods><methods><class-id>UserAndClassListInterface</class-id> <category>aspects</category><body package="view" selector="classList">classList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^classList isNil		ifTrue:			[classList := SelectionInList new]		ifFalse:			[classList]</body></methods><methods><class-id>UserAndClassListInterface</class-id> <category>aspects</category><body package="view" selector="userList">userList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^userList isNil		ifTrue:			[userList := SelectionInList new]		ifFalse:			[userList]</body></methods><comment><class-id>UserAndClassListInterface</class-id><body>UserAndClassListInterface has not been commented.  The comment should state the purpose of the class and also explain any unobvious aspects of the implementation.Instance Variables:	classDetails	&lt;ValueHolder&gt;	description of classDetails	classList	&lt;SelectionInList&gt;	description of classList	userList	&lt;SelectionInList&gt;	description of userList</body></comment><do-it>UserAndClassListInterface organization addCategory: #'initialize-release'</do-it><methods><class-id>UserAndClassListInterface</class-id> <category>initialize-release</category><body package="view" selector="initialize">initialize	self userList list: UserArray getInstance.</body></methods><class><name>UserAndClassListInterface</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>classDetails userList classList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>view</package></attributes></class><do-it>Smalltalk defineClass: #UserAndClassListInterface	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'classDetails userList classList  '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>UserAndClassListInterface</class-id> <category>aspects</category><body package="view" selector="classDetails">classDetails	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^classDetails isNil		ifTrue:			[classDetails := ((Text2.Document new: 0)) asValue]		ifFalse:			[classDetails]</body></methods><methods><class-id>UserAndClassListInterface</class-id> <category>aspects</category><body package="view" selector="classList">classList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^classList isNil		ifTrue:			[classList := SelectionInList new]		ifFalse:			[classList]</body></methods><methods><class-id>UserAndClassListInterface</class-id> <category>aspects</category><body package="view" selector="userList">userList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^userList isNil		ifTrue:			[userList := SelectionInList new]		ifFalse:			[userList]</body></methods><methods><class-id>UserAndClassListInterface class</class-id> <category>interface specs</category><body package="view" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'User and class list' 			#bounds: #(#{Graphics.Rectangle} 496 306 1425 822 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 210 0 514 0 ) 					#name: #UserList 					#model: #userList 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #onChangeUserList ) 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 213 0 -1 0 460 0 515 0 ) 					#name: #ClassList 					#model: #classList 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #onChangeClassList ) 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.DocumentViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 461 0 -1 0 920 0 513 0 ) 					#name: #ClassDetails 					#isOpaque: true 					#model: #classDetails 					#isWrapped: true 					#isReadOnly: true 					#showHiddenCharacters: false 					#showLineStriping: false 					#autoAccept: true 					#continuousAccept: false 					#showInputCursor: false 					#showSelection: true ) ) ) )</body></methods><class><name>UserAndClassListInterface</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>classDetails userList classList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>view</package></attributes></class><do-it>Smalltalk defineClass: #UserAndClassListInterface	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'classDetails userList classList  '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>UserAndClassListInterface</class-id> <category>aspects</category><body package="view" selector="classList">classList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^classList isNil		ifTrue:			[classList := SelectionInList new]		ifFalse:			[classList]</body></methods><class><name>UserAndClassListInterface</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>classDetails userList classList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>view</package></attributes></class><do-it>Smalltalk defineClass: #UserAndClassListInterface	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'classDetails userList classList  '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>UserAndClassListInterface</class-id> <category>aspects</category><body package="view" selector="userList">userList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^userList isNil		ifTrue:			[userList := SelectionInList new]		ifFalse:			[userList]</body></methods><class><name>UserAndClassListInterface</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>classDetails userList classList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>view</package></attributes></class><do-it>Smalltalk defineClass: #UserAndClassListInterface	superclass: #{UI.ApplicationModel}	indexedType: #none	private: false	instanceVariableNames: 'classDetails userList classList  '	classInstanceVariableNames: ''	imports: ''	category: ''</do-it><methods><class-id>UserAndClassListInterface</class-id> <category>aspects</category><body package="view" selector="classList">classList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^classList isNil		ifTrue:			[classList := SelectionInList new]		ifFalse:			[classList]</body></methods><methods><class-id>UserAndClassListInterface</class-id> <category>aspects</category><body package="view" selector="onChangeUserList">onChangeUserList</body></methods><methods><class-id>UserAndClassListInterface</class-id> <category>aspects</category><body package="view" selector="onChangeUserList">onChangeUserList	</body></methods><methods><class-id>UserAndClassListInterface</class-id> <category>aspects</category><body package="view" selector="onChangeUserList">onChangeUserList	self closeRequest.</body></methods><methods><class-id>UserAndClassListInterface</class-id> <category>aspects</category><body package="view" selector="onChangeUserList">onChangeUserList	Object allSubclasses do: [:c |		((c class author) = (userList selection))	].	"classList list:" </body></methods><methods><class-id>UserAndClassListInterface</class-id> <category>aspects</category><body package="view" selector="onChangeUserList">onChangeUserList	| classes |	Object allSubclasses do: [:c |		((c class author) = (userList selection))		ifTrue: [					].	].	"classList list:" </body></methods><methods><class-id>UserAndClassListInterface</class-id> <category>aspects</category><body package="view" selector="onChangeUserList">onChangeUserList	| classes |	classes := Array new.		Object allSubclasses do: [:c |		((c class author) = (userList selection))		ifTrue: [					].	].	"classList list:" </body></methods><methods><class-id>UserAndClassListInterface</class-id> <category>aspects</category><body package="view" selector="onChangeUserList">onChangeUserList	| classes |	classes := Array new.		Object allSubclasses do: [:c |		((c class author) = (userList selection))		ifTrue: [					].	].	classList list: classes.</body></methods><methods><class-id>UserAndClassListInterface</class-id> <category>aspects</category><body package="view" selector="onChangeUserList">onChangeUserList	| classes |	classes := Array new.		Object allSubclasses do: [:c |		((c class author) = (userList selection))		ifTrue: [			classes add: c.		].	].	classList list: classes.</body></methods><methods><class-id>UserAndClassListInterface</class-id> <category>aspects</category><body package="view" selector="onChangeUserList">onChangeUserList	| classes |	classes := Array new.		Object allSubclasses do: [:c |		((c class author) = (userList selection))		ifTrue: [			classes add: 'c'.		].	].	classList list: classes.</body></methods><methods><class-id>UserAndClassListInterface</class-id> <category>aspects</category><body package="view" selector="onChangeUserList">onChangeUserList	| classes |	classes := Array new: 10.		Object allSubclasses do: [:c |		((c class author) = (userList selection))		ifTrue: [			classes add: 'c'.		].	].	classList list: classes.</body></methods><methods><class-id>UserAndClassListInterface</class-id> <category>aspects</category><body package="view" selector="onChangeUserList">onChangeUserList	| classes |	classes := Array new: 10.		Object allSubclasses do: [:c |		((c class author) = (userList selection))		"ifTrue: [			classes add: 'c'.		]."	].	classList list: classes.</body></methods><methods><class-id>UserAndClassListInterface</class-id> <category>aspects</category><body package="view" selector="onChangeUserList">onChangeUserList	| classes |	classes := Array new: 10.	"	Object allSubclasses do: [:c |		((c class author) = (userList selection))		ifTrue: [			classes add: 'c'.		].	]."	classList list: classes.</body></methods><methods><class-id>UserAndClassListInterface</class-id> <category>aspects</category><body package="view" selector="onChangeUserList">onChangeUserList	| classes |	classes := Array new: 10.		Object allSubclasses do: [:c |"		((c class author) = (userList selection))		ifTrue: ["			classes add: 'c'.		"]."	].	classList list: classes.</body></methods><methods><class-id>UserAndClassListInterface</class-id> <category>aspects</category><body package="view" selector="onChangeUserList">onChangeUserList	| classes |	classes := Array new: 10.		Object allSubclasses do: [:c |"		((c class author) = (userList selection))		ifTrue: ["			classes at: 1 put: 'c'.		"]."	].	classList list: classes.</body></methods><methods><class-id>UserAndClassListInterface</class-id> <category>aspects</category><body package="view" selector="onChangeUserList">onChangeUserList	| classes |	classes := Array new: (Object allSubclasses size).		Object allSubclasses do: [:c |"		((c class author) = (userList selection))		ifTrue: ["			classes at: 1 put: 'c'.		"]."	].	classList list: classes.</body></methods><methods><class-id>UserAndClassListInterface</class-id> <category>aspects</category><body package="view" selector="onChangeUserList">onChangeUserList	| classes i |	classes := Array new: (Object allSubclasses size).		Object allSubclasses do: [:c |"		((c class author) = (userList selection))		ifTrue: ["			classes at: 1 put: 'c'.		"]."	].	classList list: classes.</body></methods><methods><class-id>UserAndClassListInterface</class-id> <category>aspects</category><body package="view" selector="onChangeUserList">onChangeUserList	| classes i |	classes := Array new: (Object allSubclasses size).	i := 0.		Object allSubclasses do: [:c |"		((c class author) = (userList selection))		ifTrue: ["			classes at: 1 put: 'c'.		"]."	].	classList list: classes.</body></methods><methods><class-id>UserAndClassListInterface</class-id> <category>aspects</category><body package="view" selector="onChangeUserList">onChangeUserList	| classes i |	classes := Array new: (Object allSubclasses size).	i := 0.		Object allSubclasses do: [:c |		((c class author) = (userList selection))		ifTrue: [			classes at: (i := i +1) put: c.		].	].	classList list: classes.</body></methods><methods><class-id>UserAndClassListInterface</class-id> <category>aspects</category><body package="view" selector="onChangeUserList">onChangeUserList	| classes i |	classes := Array new: (Object allSubclasses size).	i := 0.		Object allSubclasses do: [:c |		((c class author) = (userList selection))		ifTrue: [			classes at: (i := i +1) put: 'c'.		].	].	classList list: classes.</body></methods><do-it>Array new: (Object allSubclasses size).</do-it><methods><class-id>UserAndClassListInterface</class-id> <category>aspects</category><body package="view" selector="onChangeUserList">onChangeUserList	| classes i |	classes := Array new: 2.	i := 0.		Object allSubclasses do: [:c |		((c class author) = (userList selection))		ifTrue: [			classes at: 1 put: 'c'.		].	].	classList list: classes.</body></methods><methods><class-id>UserAndClassListInterface</class-id> <category>aspects</category><body package="view" selector="onChangeUserList">onChangeUserList	| classes |	classes := Array new: 2.		Object allSubclasses do: [:c |		((c class author) = (userList selection))		ifTrue: [			classes at: 1 put: 'c'.		].	].	classList list: classes.</body></methods><methods><class-id>UserAndClassListInterface</class-id> <category>aspects</category><body package="view" selector="onChangeUserList">onChangeUserList	| classes |	classes := Array new: 2.		Object allSubclasses do: [:c |		((c class author) == (userList selection))		ifTrue: [			classes at: 1 put: 'c'.		].	].	classList list: classes.</body></methods><methods><class-id>UserAndClassListInterface</class-id> <category>aspects</category><body package="view" selector="onChangeUserList">onChangeUserList	| classes |	classes := Array new: 2.		Object allSubclasses do: [:c |		((c class author) = (userList selection))		ifTrue: [			classes at: 1 put: 'c'.		].	].	classList list: classes.</body></methods><do-it>UserArray class</do-it><do-it>Class class.</do-it><do-it>UserArray class</do-it><do-it>UserArray</do-it><do-it>UserArray author</do-it><do-it>UserArray author</do-it><methods><class-id>UserAndClassListInterface</class-id> <category>aspects</category><body package="view" selector="onChangeUserList">onChangeUserList	| classes |	classes := Array new: 2.		Object allSubclasses do: [:c |		((c author) = (userList selection))		ifTrue: [			classes at: 1 put: 'c'.		].	].	classList list: classes.</body></methods><do-it>Class author.</do-it><methods><class-id>UserAndClassListInterface</class-id> <category>aspects</category><body package="view" selector="onChangeUserList">onChangeUserList	| classes |	classes := Array new: 2.		Object allSubclasses do: [:c |		(c author isNil)		ifFalse: [			((c author) = (userList selection))			ifTrue: [				classes at: 1 put: 'c'.			].		].	].	classList list: classes.</body></methods><methods><class-id>UserAndClassListInterface</class-id> <category>aspects</category><body package="view" selector="onChangeUserList">onChangeUserList	| classes |	classes := Array new: 2.		Object allSubclasses do: [:c |		(c author isNil)		ifFalse: [			(c author) = (userList selection)			ifTrue: [				classes at: 1 put: 'c'.			].		].	].	classList list: classes.</body></methods><methods><class-id>UserAndClassListInterface</class-id> <category>aspects</category><body package="view" selector="onChangeUserList">onChangeUserList	| classes |	classes := Array new: 2.		Object allSubclasses do: [:c |		(c author isNil)		ifFalse: [			(c author asValue) = (userList selection asValue)			ifTrue: [				classes at: 1 put: 'c'.			].		].	].	classList list: classes.</body></methods><methods><class-id>UserAndClassListInterface</class-id> <category>aspects</category><body package="view" selector="onChangeUserList">onChangeUserList	| classes |	classes := Array new: 2.		Object allSubclasses do: [:c |		(c author isNil)		ifFalse: [			(c author asValue) = (userList selection asText)			ifTrue: [				classes at: 1 put: 'c'.			].		].	].	classList list: classes.</body></methods><methods><class-id>UserAndClassListInterface</class-id> <category>aspects</category><body package="view" selector="onChangeUserList">onChangeUserList	| classes |	classes := Array new: 2.		Object allSubclasses do: [:c |		(c author isNil)		ifFalse: [			(c author asString) = (userList selection asString)			ifTrue: [				classes at: 1 put: 'c'.			].		].	].	classList list: classes.</body></methods><methods><class-id>UserAndClassListInterface</class-id> <category>aspects</category><body package="view" selector="onChangeUserList">onChangeUserList	| classes |	classes := Array new: 2.		Object allSubclasses do: [:c |		(c author isNil)		ifFalse: [			(c author asString) = (userList selection asString)"			ifTrue: [				classes at: 1 put: 'c'.			]."		].	].	classList list: classes.</body></methods><methods><class-id>UserAndClassListInterface</class-id> <category>aspects</category><body package="view" selector="onChangeUserList">onChangeUserList	| classes |	classes := Array new: 2.		Object allSubclasses do: [:c |		(c author isNil)		ifFalse: ["			(c author asString) = (userList selection asString)""			ifTrue: [				classes at: 1 put: 'c'.			]."		].	].	classList list: classes.</body></methods><methods><class-id>UserAndClassListInterface</class-id> <category>aspects</category><body package="view" selector="onChangeUserList">onChangeUserList	| classes |	classes := Array new: 2.		Object allSubclasses do: [:c |		(c author isNil)"		ifFalse: [			(c author asString) = (userList selection asString)			ifTrue: [				classes at: 1 put: 'c'.			].		]."	].	classList list: classes.</body></methods><do-it>UserArray author isNil</do-it><do-it>UserArray author = nil</do-it><methods><class-id>UserAndClassListInterface</class-id> <category>aspects</category><body package="view" selector="onChangeUserList">onChangeUserList	| classes |	classes := Array new: 2.		Object allSubclasses do: [:c |"		(c author isNil)		ifFalse: [			(c author asString) = (userList selection asString)			ifTrue: [				classes at: 1 put: 'c'.			].		]."	].	classList list: classes.</body></methods><methods><class-id>UserAndClassListInterface</class-id> <category>aspects</category><body package="view" selector="onChangeUserList">onChangeUserList	| classes |	classes := Array new: 2.		Object allSubclasses do: [:c |"		(c author isNil)		ifFalse: [			(c author asString) = (userList selection asString)			ifTrue: ["				classes at: 1 put: 'c'."			].		]."	].	classList list: classes.</body></methods><methods><class-id>UserAndClassListInterface</class-id> <category>aspects</category><body package="view" selector="onChangeUserList">onChangeUserList	| classes |	classes := Array new: 1.		Object allSubclasses do: [:c |"		(c author isNil)		ifFalse: [			(c author asString) = (userList selection asString)			ifTrue: ["				classes at: 1 put: 'c'."			].		]."	].	classList list: classes.</body></methods><methods><class-id>UserAndClassListInterface</class-id> <category>aspects</category><body package="view" selector="onChangeUserList">onChangeUserList	| classes |	classes := Array new: 1.		Object allSubclasses do: [:c |		c print."		(c author isNil)		ifFalse: [			(c author asString) = (userList selection asString)			ifTrue: ["				classes at: 1 put: 'c'."			].		]."	].	classList list: classes.</body></methods><methods><class-id>UserAndClassListInterface</class-id> <category>aspects</category><body package="view" selector="onChangeUserList">onChangeUserList	| classes |	classes := Array new: 1.		Object allSubclasses do: [:c |		c printIt."		(c author isNil)		ifFalse: [			(c author asString) = (userList selection asString)			ifTrue: ["				classes at: 1 put: 'c'."			].		]."	].	classList list: classes.</body></methods><do-it>classes := Array new: 1.Object allSubclasses do: [:d |].</do-it><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>UserAndClassListInterface</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>UserAndClassListInterface</staticKey> <definitionChange>added</definitionChange></component_static_change><do-it>UserAndClassListInterface removeFromSystem</do-it><class><name>ClassCreationDialog</name><environment>Tools</environment><super>Tools.DefinitionCreationDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>indexedTypeHolder instanceVariablesHolder indexedTypeChoices superclassModule createInitializeHolder createAccessorsHolder defineSubclassResponsibilitiesHolder tabHolder classInstanceVariablesHolder lastSubBuilder </inst-vars><class-inst-vars></class-inst-vars><imports>			private Refactory.Browser.Navigator			</imports><category>Tools-Programming</category><attributes><package>Tools-Programming</package></attributes></class><do-it>Tools defineClass: #ClassCreationDialog	superclass: #{Tools.DefinitionCreationDialog}	indexedType: #none	private: false	instanceVariableNames: 'indexedTypeHolder instanceVariablesHolder indexedTypeChoices superclassModule createInitializeHolder createAccessorsHolder defineSubclassResponsibilitiesHolder tabHolder classInstanceVariablesHolder lastSubBuilder  '	classInstanceVariableNames: ''	imports: '			private Refactory.Browser.Navigator			'	category: 'Tools-Programming'</do-it><methods><class-id>Tools.ClassCreationDialog</class-id> <category>actions</category><body package="Tools-Programming" selector="choiceUser">choiceUser	"This stub method was generated by UIDefiner"	^self</body></methods><methods><class-id>Tools.ClassCreationDialog class</class-id> <category>interface specs</category><body package="Tools-Programming" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #NewClass 				#defaultString: 'New Class' 				#catalogID: #dialogs ) 			#min: #(#{Core.Point} 20 20 ) 			#max: #(#{Core.Point} 1024 768 ) 			#bounds: #(#{Graphics.Rectangle} 763 450 1223 800 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TabControlSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 10 0 -10 1 -45 1 ) 					#name: #tabControl 					#model: #tabHolder 					#labels: #() ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -90 1 -35 1 -10 1 -10 1 ) 					#name: #cancelButton 					#model: #cancel 					#label: 					#(#{Kernel.UserMessage} 						#key: #Cancel 						#defaultString: 'Cancel' 						#catalogID: #labels ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -180 1 -35 1 -100 1 -10 1 ) 					#name: #okButton 					#model: #accept 					#label: 					#(#{Kernel.UserMessage} 						#key: #OK 						#defaultString: 'OK' 						#catalogID: #labels ) 					#isDefault: true 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 15 0 319 0 93 0 340 0 ) 					#name: #ChoiceUser 					#model: #choiceUser 					#label: 'Choice user' 					#defaultable: true ) ) ) )</body></methods><do-it>ChoiceUserInterface open.</do-it><methods><class-id>Tools.ClassCreationDialog</class-id> <category>actions</category><body package="Tools-Programming" selector="choiceUser">choiceUser	"This stub method was generated by UIDefiner"	ChoiceUserInterface open.	^self</body></methods><do-it>ChoiceUserInterface open.</do-it><methods><class-id>Tools.ClassCreationDialog</class-id> <category>actions</category><body package="Tools-Programming" selector="choiceUser">choiceUser	"This stub method was generated by UIDefiner"	ChoiceUserInterface open.</body></methods><methods><class-id>Tools.ClassCreationDialog</class-id> <category>actions</category><body package="Tools-Programming" selector="choiceUser">choiceUser	"Allow to user to choice who create the class"	ChoiceUserInterface open.</body></methods><methods><class-id>Tools.ClassCreationDialog</class-id> <category>actions</category><body package="Tools-Programming" selector="choiceUser">choiceUser	"Allow user to choice who create the class"	ChoiceUserInterface open.</body></methods><methods><class-id>Tools.ClassCreationDialog</class-id> <category>actions</category><body package="Tools-Programming" selector="choiceUser">choiceUser	"Allow user to choice who create the class"	ChoiceUserInterface openOn: self</body></methods><methods><class-id>Tools.ClassCreationDialog</class-id> <category>actions</category><body package="Tools-Programming" selector="choiceUser">choiceUser	"Allow user to choice who create the class"	ChoiceUserInterface open.</body></methods><methods><class-id>Tools.ClassCreationDialog</class-id> <category>actions</category><body package="Tools-Programming" selector="choiceUser">choiceUser	"Allow user to choice who create the class"	ChoiceUserInterface new open.</body></methods><do-it>ChoiceUserInterface new open.</do-it><do-it>ChoiceUserInterface open.</do-it><do-it>ChoiceUserInterface new open.</do-it><class><name>Test</name><environment>Smalltalk</environment><super>ChoiceUserInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>view</package></attributes></class><methods><class-id>Test</class-id> <category>initialize-release</category><body package="view" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><component_static_change><name>System-Name Spaces</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>Test</staticKey> <definitionChange>removed</definitionChange></component_static_change><component_static_change><name>(none)</name> <type>package</type><definitionName>Root.Smalltalk.Kernel.Undeclared</definitionName> <staticKey>Test</staticKey> <definitionChange>added</definitionChange></component_static_change><do-it>Test removeFromSystem</do-it><class><name>Test</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>view</package></attributes></class><methods><class-id>Test</class-id> <category>initialize-release</category><body package="view" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>Test class</class-id> <category>instance creation</category><body package="view" selector="new">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><do-it>Test</do-it><do-it>Test removeFromSystem</do-it><class><name>Test</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>view</package></attributes></class><methods><class-id>Test</class-id> <category>initialize-release</category><body package="view" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>Test class</class-id> <category>instance creation</category><body package="view" selector="new">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><do-it>Test</do-it><do-it>Test removeFromSystem</do-it><comment><class-id>UserArray</class-id><body>UserArray has not been commented.  The comment should state the purpose of the class and also explain any unobvious aspects of the implementation.currentUser	&lt;String&gt; user who create the classes</body></comment><comment><class-id>UserArray</class-id><body>UserArray has not been commented.  The comment should state the purpose of the class and also explain any unobvious aspects of the implementation.Instance Variables;	currentUser		&lt;String&gt; user who create the classes</body></comment><comment><class-id>UserArray</class-id><body>UserArray has not been commented.  The comment should state the purpose of the class and also explain any unobvious aspects of the implementation.Instance Variables;	currentUser		&lt;String&gt;	user who create the classes</body></comment><comment><class-id>UserArray</class-id><body>UserArray has not been commented.  The comment should state the purpose of the class and also explain any unobvious aspects of the implementation.Instance Variables:	currentUser		&lt;String&gt;	user who create the classesClass Instance Variables:</body></comment><comment><class-id>UserArray</class-id><body>UserArray has not been commented.  The comment should state the purpose of the class and also explain any unobvious aspects of the implementation.Instance Variables:	currentUser		&lt;String&gt;	user who create the classesClass Instance Variables:	classInstance	&lt;UserArray&gt;	the instance of this class</body></comment><comment><class-id>ManageUserController</class-id><body>ManageUserController has not been commented.  The comment should state the purpose of the class and also explain any unobvious aspects of the implementation.Instance Variables:</body></comment><comment><class-id>ManageUserController</class-id><body>ManageUserController has not been commented.  The comment should state the purpose of the class and also explain any unobvious aspects of the implementation.Instance Variables:	users	&lt;UserArray&gt;	list of all users</body></comment><comment><class-id>ChoiceUserInterface</class-id><body>ChoiceUserInterface has not been commented.  The comment should state the purpose of the class and also explain any unobvious aspects of the implementation.Instance Variables:	userChoice	&lt;String&gt;	the user which is choose</body></comment><comment><class-id>ChoiceUserInterface</class-id><body>ChoiceUserInterface has not been commented.  The comment should state the purpose of the class and also explain any unobvious aspects of the implementation.Instance Variables:	userChoice	&lt;String&gt;	the user which is choose	userChoices		&lt;List&gt;		list of user that we can choose</body></comment><comment><class-id>ChoiceUserInterface</class-id><body>ChoiceUserInterface has not been commented.  The comment should state the purpose of the class and also explain any unobvious aspects of the implementation.Instance Variables:	userChoice	&lt;String&gt;	the user which is choose	userChoices		&lt;Array&gt;		list of user that we can choose</body></comment><comment><class-id>ManageUserInterface</class-id><body>ManageUserInterface has not been commented.  The comment should state the purpose of the class and also explain any unobvious aspects of the implementation.Instance Variables:	userName	&lt;String&gt; user name that we can add</body></comment><comment><class-id>ManageUserInterface</class-id><body>ManageUserInterface has not been commented.  The comment should state the purpose of the class and also explain any unobvious aspects of the implementation.Instance Variables:	userName	&lt;String&gt; user name that we can add	us</body></comment><comment><class-id>ManageUserInterface</class-id><body>ManageUserInterface has not been commented.  The comment should state the purpose of the class and also explain any unobvious aspects of the implementation.Instance Variables:	userName	&lt;String&gt; user name that we can add	userList</body></comment><comment><class-id>ManageUserInterface</class-id><body>ManageUserInterface has not been commented.  The comment should state the purpose of the class and also explain any unobvious aspects of the implementation.Instance Variables:	userName	&lt;String&gt;	user name that we can add	userList		&lt;Array&gt;	list of all users</body></comment><component-property><name>info606</name> <type>bundle</type><property>notice</property> <value>'This bundle was made by Kevin Traini, Jules Finck, Jules Geyer, Florian Deschenaux and Irilind Salihi'</value></component-property><component-property><name>info606</name> <type>bundle</type><property>notice</property> <value>'This bundle was made by Kevin Traini, Jules Finck, Jules Geyer, Florian Deschenaux and Irilind SalihiInfo606 Programmation orient objet III'</value></component-property><component-property><name>info606</name> <type>bundle</type><property>notice</property> <value>'This bundle was code by Kevin Traini, Jules Finck, Jules Geyer, Florian Deschenaux and Irilind SalihiInfo606 Programmation orient objet III'</value></component-property><component-property><name>info606</name> <type>bundle</type><property>notice</property> <value>'This bundle was code by Kevin Traini, Jules Finck, Jules Geyer, Florian Deschenaux and Irilind SalihiInfo606 Programmation orient objet III with Christophe Roche'</value></component-property>